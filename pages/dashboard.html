<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard - WR10</title>
    
    <!-- Fontes -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    
    <!-- CSS -->
    <link rel="stylesheet" href="../assets/css/style.css">
    
    <style>
        /* Prevenir overflow horizontal global */
        body, html {
            overflow-x: hidden;
            max-width: 100%;
        }
        
        .main-content {
            overflow-x: hidden;
            max-width: 100%;
        }
        
        .content-body {
            overflow-x: hidden;
            max-width: 100%;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: var(--spacing-lg);
            margin-bottom: var(--spacing-xl);
            align-items: start;
            grid-auto-rows: min-content;
        }
        
        /* Ajustes para tablets */
        @media (max-width: 768px) {
            .stats-grid {
                grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
                gap: var(--spacing-md);
                margin-bottom: var(--spacing-lg);
            }
        }
        
        /* Ajustes para mobile */
        @media (max-width: 480px) {
            .stats-grid {
                grid-template-columns: 1fr;
                gap: var(--spacing-sm);
                margin-bottom: var(--spacing-md);
            }
        }
        
        .chart-container {
            position: relative;
            height: 450px;
            background: var(--white);
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
            border: 1px solid var(--border-gray);
            box-shadow: var(--shadow-sm);
            overflow: visible;
        }
        
        @media (max-width: 768px) {
            .chart-container {
                overflow-x: hidden;
                padding: var(--spacing-md);
            }
        }
        
        @media (max-width: 480px) {
            .chart-container {
                padding: var(--spacing-sm);
            }
        }
        
        .chart-container canvas {
            max-height: 360px !important;
            width: 100% !important;
            height: 360px !important;
            display: block;
            box-sizing: border-box;
        }
        
        /* Melhorar espaçamento entre elementos dos gráficos */
        .chart-header {
            flex-shrink: 0;
            min-height: 60px;
        }
        
        .chart-title {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 200px;
        }
        
        .filter-selector {
            min-width: 120px;
            flex-shrink: 0;
        }
        
        /* Garantir que não há overflow ou sobreposição */
        .dashboard-content * {
            box-sizing: border-box;
        }
        
        /* Melhor controle de texto nos gráficos */
        .chart-container .chartjs-tooltip {
            z-index: 1000 !important;
        }
        
        /* Canvas não deve bloquear cliques nos botões */
        .chart-container canvas {
            position: relative;
            z-index: 1;
        }
        
        /* Header e controles devem ficar acima do canvas */
        .chart-header {
            position: relative;
            z-index: 10;
        }
        
        .chart-settings-dropdown {
            z-index: 1001 !important;
        }
        
        /* Evitar sobreposição de elementos */
        .col-4 {
            min-width: 0;
            overflow: hidden;
        }
        
        /* Links desabilitados */
        .sidebar-nav-link.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
            position: relative;
        }
        
        .sidebar-nav-link.disabled::after {
            content: "Em breve";
            position: absolute;
            right: 12px;
            font-size: 0.75rem;
            background: var(--text-gray);
            color: var(--white);
            padding: 2px 6px;
            border-radius: 10px;
        }
        
        .chart-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--spacing-lg);
            padding-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--border-gray);
            gap: var(--spacing-md);
            flex-wrap: wrap;
            position: relative;
        }
        
        .chart-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--dark-gray);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            white-space: nowrap;
            flex-shrink: 0;
            margin: 0;
        }
        
        .chart-title i {
            flex-shrink: 0;
        }
        
        .chart-actions {
            display: flex;
            gap: var(--spacing-sm);
            flex-shrink: 0;
            position: relative;
        }
        
        .filter-selector {
            padding: var(--spacing-xs) var(--spacing-sm);
            border: 1px solid var(--border-gray);
            border-radius: var(--radius-md);
            font-size: 0.875rem;
            background: var(--white);
            cursor: pointer;
            min-width: 130px;
            flex-shrink: 0;
        }
        
        /* Botões de controle de gráfico */
        .chart-control-btn {
            padding: var(--spacing-xs) var(--spacing-sm);
            border: 1px solid var(--border-gray);
            border-radius: var(--radius-md);
            background: var(--white);
            cursor: pointer;
            font-size: 0.875rem;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            transition: var(--transition);
            color: var(--dark-gray);
            white-space: nowrap;
        }
        
        .chart-control-btn:hover {
            background: var(--light-gray);
            border-color: #3182ce;
            color: #3182ce;
        }
        
        .chart-control-btn.active {
            background: #3182ce;
            color: var(--white);
            border-color: #3182ce;
        }
        
        .chart-control-btn i {
            font-size: 0.875rem;
        }
        
        /* Ajustes para botões em mobile */
        @media (max-width: 768px) {
            .chart-control-btn {
                padding: var(--spacing-xs);
                font-size: 0.8rem;
                gap: 4px;
            }
            
            .chart-control-btn i {
                font-size: 0.8rem;
            }
        }
        
        @media (max-width: 480px) {
            .chart-control-btn {
                padding: 6px 8px;
                font-size: 0.75rem;
            }
            
            .chart-control-btn span {
                display: none; /* Ocultar texto, mostrar apenas ícone */
            }
            
            .chart-control-btn i {
                font-size: 0.9rem;
                margin: 0;
            }
        }
        
        /* Dropdown de personalização */
        .chart-settings-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 8px;
            background: var(--white);
            border: 1px solid var(--border-gray);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-lg);
            padding: var(--spacing-md);
            min-width: 250px;
            max-width: 90vw;
            z-index: 1000;
            display: none;
        }
        
        .chart-settings-dropdown.show {
            display: block;
        }
        
        /* Ajustar dropdown em mobile para não causar overflow */
        @media (max-width: 768px) {
            .chart-settings-dropdown {
                position: absolute;
                right: 10px;
                left: auto;
                top: 100%;
                min-width: 240px;
                max-width: calc(100vw - 40px);
                transform: none;
                margin-top: 8px;
            }
            
            /* Garantir que o container de ações seja o contexto de posicionamento */
            .chart-header {
                position: relative;
            }
        }
        
        @media (max-width: 480px) {
            .chart-settings-dropdown {
                min-width: 220px;
                max-width: calc(100vw - 30px);
                padding: var(--spacing-sm);
                right: 5px;
            }
        }
        
        .chart-settings-section {
            margin-bottom: var(--spacing-md);
        }
        
        .chart-settings-section:last-child {
            margin-bottom: 0;
        }
        
        .chart-settings-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--dark-gray);
            margin-bottom: var(--spacing-xs);
            display: block;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .chart-type-buttons {
            display: flex;
            gap: var(--spacing-xs);
        }
        
        .chart-type-btn {
            flex: 1;
            padding: var(--spacing-xs);
            border: 1px solid var(--border-gray);
            border-radius: var(--radius-sm);
            background: var(--white);
            cursor: pointer;
            font-size: 0.75rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            transition: var(--transition);
            color: var(--text-gray);
        }
        
        .chart-type-btn:hover {
            background: var(--light-gray);
            border-color: #3182ce;
        }
        
        .chart-type-btn.active {
            background: #3182ce;
            color: var(--white);
            border-color: #3182ce;
        }
        
        .chart-type-btn i {
            font-size: 1.25rem;
        }
        
        .chart-settings-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--spacing-xs) 0;
            font-size: 0.875rem;
            color: var(--dark-gray);
        }
        
        .toggle-switch {
            position: relative;
            width: 40px;
            height: 20px;
            background: #cbd5e0;
            border-radius: 20px;
            cursor: pointer;
            transition: var(--transition);
        }
        
        .toggle-switch.active {
            background: #48bb78;
        }
        
        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: var(--white);
            border-radius: 50%;
            transition: var(--transition);
        }
        
        .toggle-switch.active::after {
            left: 22px;
        }
        
        .no-data {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 300px;
            color: var(--text-gray);
            text-align: center;
        }
        
        .no-data i {
            font-size: 3rem;
            margin-bottom: var(--spacing-md);
            opacity: 0.5;
        }
        
        .device-status {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-md);
            padding: var(--spacing-sm);
            background: var(--light-gray);
            border-radius: var(--radius-md);
            font-size: 0.875rem;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success);
        }
        
        .status-dot.offline {
            background: var(--error);
        }
        
        .latest-readings {
            background: var(--white);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border-gray);
            box-shadow: var(--shadow-sm);
        }
        
        .readings-header {
            padding: var(--spacing-lg);
            border-bottom: 1px solid var(--border-gray);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .readings-list {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .reading-item {
            padding: var(--spacing-md) var(--spacing-lg);
            border-bottom: 1px solid var(--border-gray);
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: var(--transition);
        }
        
        .reading-item:last-child {
            border-bottom: none;
        }
        
        .reading-item:hover {
            background: var(--light-gray);
        }
        
        .reading-info {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
        }
        
        .reading-icon {
            width: 40px;
            height: 40px;
            border-radius: var(--radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--white);
            font-size: 1.125rem;
        }
        
        .reading-icon.humidity {
            background: linear-gradient(135deg, var(--info), #63b3ed);
        }
        
        .reading-icon.rain {
            background: linear-gradient(135deg, var(--accent-green), var(--light-green));
        }
        
        .reading-details h6 {
            margin: 0 0 var(--spacing-xs) 0;
            font-weight: 600;
            color: var(--dark-gray);
        }
        
        .reading-details p {
            margin: 0;
            font-size: 0.875rem;
            color: var(--text-gray);
        }
        
        .reading-values {
            text-align: right;
        }
        
        .reading-value {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--dark-gray);
            margin-bottom: var(--spacing-xs);
        }
        
        .reading-time {
            font-size: 0.75rem;
            color: var(--text-gray);
        }
        
        .empty-state {
            padding: var(--spacing-2xl);
            text-align: center;
            color: var(--text-gray);
        }
        
        .empty-state i {
            font-size: 3rem;
            margin-bottom: var(--spacing-md);
            opacity: 0.5;
        }
        
        /* ===== MENU HAMBURGUER ===== */
        .btn-hamburger {
            display: none;
            flex-direction: column;
            justify-content: space-around;
            width: 44px;
            height: 44px;
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 8px;
            border-radius: var(--radius-md);
            transition: var(--transition);
            position: relative;
        }
        
        .btn-hamburger:hover {
            background: var(--light-gray);
        }
        
        .btn-hamburger:active {
            background: var(--medium-gray);
        }
        
        .hamburger-line {
            display: block;
            height: 3px;
            width: 100%;
            background: var(--dark-gray);
            border-radius: 2px;
            transition: var(--transition);
            transform-origin: center;
        }
        
        /* Animação do hamburguer para X */
        .btn-hamburger.active .hamburger-line:nth-child(1) {
            transform: translateY(8px) rotate(45deg);
        }
        
        .btn-hamburger.active .hamburger-line:nth-child(2) {
            opacity: 0;
        }
        
        .btn-hamburger.active .hamburger-line:nth-child(3) {
            transform: translateY(-8px) rotate(-45deg);
        }
        
        /* Overlay para fechar sidebar ao clicar fora */
        .sidebar-overlay {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background: rgba(0, 0, 0, 0.5) !important;
            z-index: 999 !important;
            opacity: 0 !important;
            visibility: hidden !important;
            transition: var(--transition) !important;
            pointer-events: none !important;
        }
        
        .sidebar-overlay.show {
            opacity: 1 !important;
            visibility: visible !important;
            pointer-events: auto !important;
        }
        
        /* Melhorias no sidebar para mobile */
        @media (max-width: 1024px) {
            .btn-hamburger {
                display: flex !important;
            }
            
            .sidebar {
                transform: translateX(-100%) !important;
                transition: transform 0.3s ease !important;
                z-index: 1001 !important;
                position: fixed !important;
            }
            
            .sidebar.show {
                transform: translateX(0) !important;
                box-shadow: var(--shadow-xl) !important;
            }
            
            .main-content {
                margin-left: 0 !important;
                transition: margin-left 0.3s ease !important;
            }
        }
        
        /* Regras adicionais para garantir funcionamento */
        @media (max-width: 1024px) {
            .sidebar {
                left: 0 !important;
                top: 0 !important;
                width: 280px !important;
                height: 100vh !important;
                background: var(--white) !important;
            }
        }
        
        /* Melhorias adicionais para telas muito pequenas */
        @media (max-width: 768px) {
            .content-header h1 {
                font-size: 1.5rem;
            }
            
            .content-header p {
                font-size: 0.875rem;
            }
            
            .btn-hamburger {
                width: 40px;
                height: 40px;
            }
        }
        
        /* CSS SIMPLIFICADO - só o essencial */
        @media (max-width: 1024px) {
            .btn-hamburger {
                display: flex !important;
                position: absolute !important;
                right: 20px !important;
                top: 20px !important;
                z-index: 100 !important;
            }
        }
        
        /* Garantir que o header tenha position relative */
        .content-header {
            position: relative !important;
        }
        
        /* MELHORIAS PARA GRÁFICOS EM DISPOSITIVOS MÓVEIS */
        
        /* Garantir que o layout de colunas funcione corretamente */
        .row {
            display: flex !important;
            gap: var(--spacing-lg) !important;
            margin-bottom: var(--spacing-lg) !important;
            max-width: 100% !important;
            overflow: visible !important;
        }
        
        .col-8 {
            flex: 2 !important;
            min-width: 0 !important;
            overflow: visible !important;
        }
        
        .col-4 {
            flex: 1 !important;
            min-width: 0 !important;
            overflow: visible !important;
        }
        
        @media (max-width: 1024px) {
            /* Fazer gráficos ocuparem largura total em tablets */
            .row {
                flex-direction: column !important;
                gap: var(--spacing-md) !important;
            }
            
            .col-8, .col-4 {
                width: 100% !important;
                max-width: 100% !important;
                flex: none !important;
            }
            
            /* Aumentar altura dos containers de gráfico em tablets */
            .chart-container {
                height: 500px !important;
                margin-bottom: var(--spacing-lg) !important;
            }
            
            .chart-container canvas {
                max-height: 400px !important;
                height: 400px !important;
            }
        }
        
        @media (max-width: 768px) {
            /* Otimizações específicas para smartphones */
            .chart-container {
                height: 450px !important;
                padding: var(--spacing-md) !important;
            }
            
            .chart-container canvas {
                max-height: 350px !important;
                height: 350px !important;
            }
            
            /* Melhorar header dos gráficos em mobile */
            .chart-header {
                flex-direction: column !important;
                align-items: flex-start !important;
                gap: var(--spacing-sm) !important;
                min-height: auto !important;
                margin-bottom: var(--spacing-md) !important;
                overflow: visible !important;
            }
            
            .chart-title {
                font-size: 0.95rem !important;
                max-width: 100% !important;
            }
            
            .chart-title span {
                white-space: normal !important;
            }
            
            .chart-actions {
                width: 100% !important;
                flex-wrap: nowrap !important;
                overflow: visible !important;
                gap: var(--spacing-xs) !important;
            }
            
            .filter-selector {
                flex: 1 !important;
                min-width: 0 !important;
                font-size: 0.8rem !important;
                padding: var(--spacing-xs) var(--spacing-sm) !important;
            }
            
            .chart-control-btn {
                flex-shrink: 0 !important;
            }
            
            /* Melhorar grid de estatísticas em mobile */
            .stats-grid {
                grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)) !important;
                gap: var(--spacing-md) !important;
            }
            
            .stats-card {
                padding: var(--spacing-md) !important;
            }
            
            .stats-card-icon {
                width: 2.25rem !important;
                height: 2.25rem !important;
                font-size: 1.125rem !important;
                margin-bottom: var(--spacing-sm) !important;
            }
            
            .stats-card-value {
                font-size: 1.625rem !important;
                margin-bottom: 0.125rem !important;
            }
            
            .stats-card-label {
                font-size: 0.75rem !important;
                line-height: 1.3 !important;
            }
        }
        
        @media (max-width: 480px) {
            /* Otimizações para telas muito pequenas */
            .chart-container {
                height: 400px !important;
                padding: var(--spacing-sm) !important;
            }
            
            .chart-container canvas {
                max-height: 300px !important;
                height: 300px !important;
            }
            
            .chart-title {
                font-size: 0.85rem !important;
            }
            
            .chart-title i {
                font-size: 0.85rem !important;
            }
            
            /* Grid de uma coluna em telas muito pequenas */
            .stats-grid {
                grid-template-columns: 1fr !important;
                gap: var(--spacing-sm) !important;
            }
            
            .stats-card {
                padding: var(--spacing-sm) var(--spacing-md) !important;
            }
            
            .stats-card-icon {
                width: 1.875rem !important;
                height: 1.875rem !important;
                font-size: 0.95rem !important;
                margin-bottom: 0.375rem !important;
                border-radius: var(--radius-sm) !important;
            }
            
            .stats-card-value {
                font-size: 1.375rem !important;
                margin-bottom: 0 !important;
                line-height: 1.1 !important;
            }
            
            .stats-card-label {
                font-size: 0.7rem !important;
                line-height: 1.25 !important;
            }
            
            /* Garantir que os filtros sejam visíveis */
            .chart-actions {
                display: flex !important;
                flex-wrap: nowrap !important;
                justify-content: stretch !important;
                gap: var(--spacing-xs) !important;
            }
            
            .filter-selector {
                flex: 1 !important;
                font-size: 0.75rem !important;
                padding: var(--spacing-xs) !important;
                min-width: 0 !important;
            }
            
            .chart-control-btn {
                padding: var(--spacing-xs) !important;
                flex-shrink: 0 !important;
            }
            
            /* Ajustar header para evitar overflow */
            .chart-header {
                overflow: visible !important;
                padding-bottom: var(--spacing-sm) !important;
            }
        }
        
        /* Media query adicional para telas médias (tablets em landscape) */
        @media (max-width: 1200px) and (min-width: 769px) {
            .chart-container {
                height: 480px !important;
            }
            
            .chart-container canvas {
                max-height: 380px !important;
                height: 380px !important;
            }
        }
    </style>
</head>

<body>
    <!-- Admin View Status Bar -->
    <div id="adminStatusBar" class="admin-status-bar" style="display: none;">
        <div class="admin-status-content">
            <i class="fas fa-eye"></i>
            <span>Modo Visualização Administrador</span>
            <span id="adminViewCompany" class="admin-view-company"></span>
            <button class="admin-status-close" onclick="returnToAdmin()">
                <i class="fas fa-times"></i>
            </button>
        </div>
    </div>
    
    <!-- Overlay para fechar sidebar em mobile -->
    <div class="sidebar-overlay" data-sidebar-overlay></div>
    
    <!-- Sidebar -->
    <aside class="sidebar">
        <div class="sidebar-header">
            <div class="navbar-brand">
                <i class="fas fa-seedling"></i>
                <span>WR10</span>
            </div>
            <p class="subtitle" style="color: var(--text-gray); font-size: 0.875rem; margin-top: var(--spacing-sm);">
                Plano Básico
            </p>
        </div>
        
        <nav>
            <ul class="sidebar-nav">
                <li class="sidebar-nav-item">
                    <a href="dashboard.html" class="sidebar-nav-link active">
                        <i class="fas fa-chart-line"></i>
                        Dashboard
                    </a>
                </li>
                <li class="sidebar-nav-item">
                    <a href="dispositivos.html" class="sidebar-nav-link">
                        <i class="fas fa-microchip"></i>
                        Dispositivos
                    </a>
                </li>
                <li class="sidebar-nav-item">
                    <a href="dados.html" class="sidebar-nav-link">
                        <i class="fas fa-database"></i>
                        Dados
                    </a>
                </li>
                <li class="sidebar-nav-item">
                    <a href="#" class="sidebar-nav-link disabled">
                        <i class="fas fa-tint"></i>
                        Irrigação
                    </a>
                </li>
                <li class="sidebar-nav-item">
                    <a href="configuracoes.html" class="sidebar-nav-link">
                        <i class="fas fa-cog"></i>
                        Configurações
                    </a>
                </li>
            </ul>
        </nav>
        
        <div style="margin-top: auto; padding-top: var(--spacing-xl);">
            <div id="adminNavItem" class="sidebar-nav-item" style="display: none;">
                <a href="admin-dashboard.html" class="sidebar-nav-link" id="adminNavLink">
                    <i class="fas fa-user-shield"></i>
                    <span id="adminNavText">Painel Admin</span>
                </a>
            </div>
            <div class="sidebar-nav-item">
                <a href="#" class="sidebar-nav-link" id="logoutBtn">
                    <i class="fas fa-sign-out-alt"></i>
                    Sair
                </a>
            </div>
            <div style="padding: var(--spacing-md); text-align: center; font-size: 0.75rem; color: var(--text-gray);">
                <div style="margin-bottom: 4px;">
                    <i class="fas fa-user"></i>
                    <span id="userInfo">Carregando...</span>
                </div>
                <div id="companyInfo" style="font-size: 0.7rem; opacity: 0.8;">
                    <i class="fas fa-building"></i>
                    <span id="companyName">-</span>
                </div>
            </div>
        </div>
    </aside>

    <!-- Conteúdo Principal -->
    <main class="main-content">
        <div class="content-header">
            <div class="d-flex justify-content-between align-items-start">
                <div class="flex-grow-1">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <div>
                            <h1 class="mb-1">Dashboard</h1>
                            <p class="mb-0 text-muted">Visão geral do sistema de monitoramento</p>
                        </div>
                        <div class="ml-auto">
                            <button class="btn-hamburger" data-sidebar-toggle aria-label="Abrir/Fechar Menu">
                                <span class="hamburger-line"></span>
                                <span class="hamburger-line"></span>
                                <span class="hamburger-line"></span>
                            </button>
                        </div>
                    </div>
                    <div class="d-flex gap-2">
                        <button class="btn btn-secondary btn-sm" onclick="loadDashboardData()">
                            <i class="fas fa-sync-alt"></i>
                            Atualizar Dados
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="content-body">
            <!-- Status Cards -->
            <div class="stats-grid">
                <div class="stats-card">
                    <div class="stats-card-icon primary">
                        <i class="fas fa-microchip"></i>
                    </div>
                    <div class="stats-card-value" id="deviceCount">0</div>
                    <div class="stats-card-label">Sensores Online</div>
                </div>
                
                <div class="stats-card">
                    <div class="stats-card-icon info">
                        <i class="fas fa-tint"></i>
                    </div>
                    <div class="stats-card-value" id="avgHumidity">0%</div>
                    <div class="stats-card-label">Umidade Média do Solo</div>
                </div>
                
                <div class="stats-card">
                    <div class="stats-card-icon warning">
                        <i class="fas fa-cloud-rain"></i>
                    </div>
                    <div class="stats-card-value" id="totalRain">0mm</div>
                    <div class="stats-card-label">Precipitação Hoje</div>
                </div>
                
                <div class="stats-card">
                    <div class="stats-card-icon success">
                        <i class="fas fa-database"></i>
                    </div>
                    <div class="stats-card-value" id="readingCount">0</div>
                    <div class="stats-card-label">Registros Hoje</div>
                </div>
            </div>
            
            <!-- Status do Dispositivo -->
            <div id="deviceStatusContainer" style="display: none;"></div>
            
            <!-- Gráficos -->
            <div class="row">
                <div class="col-8">
                    <div class="chart-container" id="humidityChartContainer">
                        <div class="chart-header">
                            <h3 class="chart-title">
                                <i class="fas fa-chart-area"></i>
                                <span>Umidade do Solo</span>
                            </h3>
                            <div class="chart-actions">
                                <select class="filter-selector" id="humidityFilter" onchange="updateHumidityChart()">
                                    <option value="24h">Últimas 24h</option>
                                    <option value="7d">Últimos 7 dias</option>
                                    <option value="30d">Últimos 30 dias</option>
                                    <option value="all">Todos os dados</option>
                                </select>
                                <div style="position: relative;">
                                    <button class="chart-control-btn" id="humiditySettingsBtn" onclick="toggleChartSettings('humidity')">
                                        <i class="fas fa-cog"></i>
                                    </button>
                                    <div class="chart-settings-dropdown" id="humiditySettings">
                                        <div class="chart-settings-section">
                                            <label class="chart-settings-label">Tipo de Gráfico</label>
                                            <div class="chart-type-buttons">
                                                <button class="chart-type-btn active" data-type="line" onclick="changeChartType('humidity', 'line')">
                                                    <i class="fas fa-chart-line"></i>
                                                    <span>Linha</span>
                                                </button>
                                                <button class="chart-type-btn" data-type="bar" onclick="changeChartType('humidity', 'bar')">
                                                    <i class="fas fa-chart-bar"></i>
                                                    <span>Barra</span>
                                                </button>
                                                <button class="chart-type-btn" data-type="area" onclick="changeChartType('humidity', 'area')">
                                                    <i class="fas fa-chart-area"></i>
                                                    <span>Área</span>
                                                </button>
                                            </div>
                                        </div>
                                        <div class="chart-settings-section">
                                            <div class="chart-settings-toggle">
                                                <span>Mostrar Grid</span>
                                                <div class="toggle-switch active" onclick="toggleChartGrid('humidity')" id="humidityGridToggle"></div>
                                            </div>
                                            <div class="chart-settings-toggle">
                                                <span>Mostrar Pontos</span>
                                                <div class="toggle-switch active" onclick="toggleChartPoints('humidity')" id="humidityPointsToggle"></div>
                                            </div>
                                            <div class="chart-settings-toggle">
                                                <span>Preencher Área</span>
                                                <div class="toggle-switch active" onclick="toggleChartFill('humidity')" id="humidityFillToggle"></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <canvas id="humidityChart"></canvas>
                    </div>
                </div>
                
                <div class="col-4">
                    <div class="chart-container" id="rainChartContainer">
                        <div class="chart-header">
                            <h3 class="chart-title">
                                <i class="fas fa-cloud-rain"></i>
                                <span>Precipitação</span>
                            </h3>
                            <div class="chart-actions">
                                <select class="filter-selector" id="rainFilter" onchange="updateRainChart()">
                                    <option value="24h">Últimas 24h</option>
                                    <option value="7d">Últimos 7 dias</option>
                                    <option value="30d">Últimos 30 dias</option>
                                    <option value="all">Todos os dados</option>
                                </select>
                                <div style="position: relative;">
                                    <button class="chart-control-btn" id="rainSettingsBtn" onclick="toggleChartSettings('rain')">
                                        <i class="fas fa-cog"></i>
                                    </button>
                                    <div class="chart-settings-dropdown" id="rainSettings">
                                        <div class="chart-settings-section">
                                            <label class="chart-settings-label">Tipo de Gráfico</label>
                                            <div class="chart-type-buttons">
                                                <button class="chart-type-btn active" data-type="line" onclick="changeChartType('rain', 'line')">
                                                    <i class="fas fa-chart-line"></i>
                                                    <span>Linha</span>
                                                </button>
                                                <button class="chart-type-btn" data-type="bar" onclick="changeChartType('rain', 'bar')">
                                                    <i class="fas fa-chart-bar"></i>
                                                    <span>Barra</span>
                                                </button>
                                                <button class="chart-type-btn" data-type="area" onclick="changeChartType('rain', 'area')">
                                                    <i class="fas fa-chart-area"></i>
                                                    <span>Área</span>
                                                </button>
                                            </div>
                                        </div>
                                        <div class="chart-settings-section">
                                            <div class="chart-settings-toggle">
                                                <span>Mostrar Grid</span>
                                                <div class="toggle-switch active" onclick="toggleChartGrid('rain')" id="rainGridToggle"></div>
                                            </div>
                                            <div class="chart-settings-toggle">
                                                <span>Mostrar Pontos</span>
                                                <div class="toggle-switch active" onclick="toggleChartPoints('rain')" id="rainPointsToggle"></div>
                                            </div>
                                            <div class="chart-settings-toggle">
                                                <span>Preencher Área</span>
                                                <div class="toggle-switch active" onclick="toggleChartFill('rain')" id="rainFillToggle"></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <canvas id="rainChart"></canvas>
                    </div>
                </div>
            </div>
                                </select>
                            </div>
                        </div>
                        <canvas id="rainChart"></canvas>
                    </div>
                </div>
            </div>
            
            <!-- Leituras Recentes -->
            <div class="latest-readings">
                <div class="readings-header">
                    <h3 class="mb-0">
                        <i class="fas fa-clock"></i>
                        Últimas Leituras
                    </h3>
                    <a href="dados.html" class="btn btn-sm btn-secondary">
                        Ver todas <i class="fas fa-arrow-right"></i>
                    </a>
                </div>
                <div class="readings-list" id="latestReadings">
                    <!-- Será preenchido via JavaScript -->
                </div>
            </div>
        </div>
    </main>

    <!-- Scripts -->
    <script src="../assets/js/app.js"></script>
    <script>
        // Variáveis globais dos gráficos
        let humidityChart = null;
        let rainChart = null;
        
        // Função de inicialização e verificações
        function initPage() {
            // Verificar se AuthManager está disponível
            if (typeof AuthManager === 'undefined') {
                console.warn('AuthManager não está disponível ainda');
                return false;
            }

            try {
                // Verificar autenticação e permissões
                if (!AuthManager.redirectIfNotAuthenticated()) {
                    throw new Error('Não autenticado');
                }

                // Verificar se é usuário comum - admins devem ir para admin-dashboard
                if (AuthManager.isAdmin()) {
                    const urlParams = new URLSearchParams(window.location.search);
                    const isAdminView = urlParams.get('admin_view') === 'true';
                    
                    // Se é admin mas não está em modo de visualização admin, redirecionar
                    if (!isAdminView && !urlParams.get('company_id')) {
                        window.location.href = 'admin-dashboard.html';
                        return false;
                    }
                    
                    // Se está em modo admin_view, criar contexto especial
                    if (isAdminView) {
                        window.adminViewMode = true;
                        window.adminViewCompanyId = urlParams.get('company_id');
                        console.log('Modo visualização admin ativado para empresa:', window.adminViewCompanyId);
                    }
                }
                return true;
            } catch (error) {
                console.error('Erro na inicialização:', error);
                return false;
            }
        }

        // Função helper para notificações
        function showNotification(type, title, message) {
            if (window.NotificationManager && typeof window.NotificationManager[type] === 'function') {
                window.NotificationManager[type](title, message);
            } else {
                // Fallback para alert se NotificationManager não estiver disponível
                alert(`${title}: ${message}`);
            }
        }
        
        // Função para interceptar cliques em links desabilitados
        function handleDisabledLinks() {
            document.querySelectorAll('.sidebar-nav-link.disabled').forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    showNotification('info', 'Funcionalidade em desenvolvimento', 'Esta funcionalidade estará disponível em breve.');
                });
            });
        }

        // Obter company_id para administradores via query parameter
        const urlParams = new URLSearchParams(window.location.search);
        const adminCompanyId = urlParams.get('company_id');
        const isAdminView = urlParams.get('admin') === 'true';

        // Dados dos sensores organizados por dispositivo
        let sensorsDataByDevice = {};
        let latestReadings = [];
        
        // Inicialização da página
        document.addEventListener('DOMContentLoaded', async function() {
            // Setup do menu mobile primeiro (não depende de APIs externas)
            setupMobileMenu();
            
            // Aguardar um pouco para garantir que app.js carregou
            setTimeout(async () => {
                try {
                    // Executar verificações de autenticação
                    const authSuccess = initPage();
                    
                    if (authSuccess) {
                        await initializeDashboard();
                        setupEventListeners();
                        handleDisabledLinks();
                    } else {
                        // Se autenticação falhou, ainda assim configurar eventos básicos
                        setupEventListeners();
                        handleDisabledLinks();
                    }
                } catch (error) {
                    console.error('Erro na inicialização:', error);
                    // Garantir que pelo menos o menu mobile funcione
                    setupEventListeners();
                }
            }, 100);
        });
        
        async function initializeDashboard() {
            try {
                LoadingManager.showGlobalLoading('Carregando dashboard...');
                
                // Carregar dados do usuário
                const user = AuthManager.getUserFromToken();
                if (user) {
                    const displayName = user.fullName || user.username || 'Usuário';
                    document.getElementById('userInfo').textContent = displayName;
                    
                    // Mostrar informações baseadas no tipo de usuário
                    if (user.userType === 'admin') {
                        document.getElementById('adminNavItem').style.display = 'block';
                        const viewCompanyId = window.adminViewCompanyId || adminCompanyId;
                        
                        // Ajustar comportamento do link admin baseado no modo
                        if (window.adminViewMode) {
                            document.getElementById('adminNavText').textContent = 'Voltar ao Admin';
                            document.getElementById('adminNavLink').title = 'Voltar ao painel administrativo';
                        }
                        
                        if (viewCompanyId) {
                            // Admin visualizando empresa específica
                            if (window.adminViewMode) {
                                document.getElementById('userInfo').textContent += ' (Visualizando como Admin)';
                            } else {
                                document.getElementById('userInfo').textContent += ' (Admin)';
                            }
                            await loadCompanyName(viewCompanyId);
                        }
                    } else if (user.userType === 'user' && user.company_id) {
                        // Usuário comum - carregar nome da empresa
                        await loadCompanyName(user.company_id);
                    }
                }
                
                // Inicializar gráficos primeiro
                initializeCharts();
                
                // Carregar dados do dashboard
                await loadDashboardData();
                
            } catch (error) {
                console.error('Erro ao inicializar dashboard:', error);
                showNotification('error', 'Erro', 'Falha ao carregar dados do dashboard');
            } finally {
                LoadingManager.hideGlobalLoading();
            }
        }

        async function loadCompanyName(companyId) {
            try {
                // Para usuários comuns, a empresa pode vir da API de configurações
                // Para admins, carregamos da API administrativa
                const user = AuthManager.getUserFromToken();
                if (user.userType === 'admin') {
                    const companies = await ApiClient.getCompanies();
                    const company = companies.companies?.find(c => c._id === companyId);
                    if (company) {
                        document.getElementById('companyName').textContent = company.nome;
                    }
                } else {
                    // Para usuários comuns, podemos tentar obter da configuração
                    document.getElementById('companyName').textContent = 'Minha Empresa';
                }
            } catch (error) {
                console.error('Erro ao carregar nome da empresa:', error);
                document.getElementById('companyName').textContent = '-';
            }
        }
        
        async function loadDashboardData() {
            try {
                // Determinar company_id para carregar dados
                const companyId = window.adminViewCompanyId || adminCompanyId || AuthManager.getCompanyId();
                
                // Carregar histórico de sensores sem filtro de período inicialmente
                // Os filtros de período serão aplicados individualmente nos gráficos
                const response = await ApiClient.getSensorsHistory(companyId);
                
                // Extrair array de dados da resposta da API
                const historyData = response?.dados || response || [];
                
                // Processar dados agrupados por dispositivo
                processMultiSensorData(historyData);
                
                // Atualizar estatísticas
                updateMultiSensorStatistics();
                
                // Atualizar status dos dispositivos
                updateMultiDeviceStatus();
                
                // Atualizar leituras recentes
                updateLatestReadings();
                
                // Atualizar gráficos com os filtros selecionados
                updateCharts();
                
            } catch (error) {
                console.error('Erro ao carregar dados:', error);
                // Mostrar mensagem de erro ao usuário
                alert('Erro ao carregar dados do servidor. Por favor, tente novamente.');
            }
        }
        
        function processMultiSensorData(rawData) {
            // Limpar dados anteriores
            sensorsDataByDevice = {};
            
            // Agrupar dados por device_key
            rawData.forEach(reading => {
                const deviceKey = reading.device_key;
                
                if (!sensorsDataByDevice[deviceKey]) {
                    // Criar nome mais amigável para o dispositivo
                    const deviceName = generateDeviceName(deviceKey);
                    
                    sensorsDataByDevice[deviceKey] = {
                        name: deviceName.name,
                        location: deviceName.location,
                        isOnline: true, // Será calculado baseado na última leitura
                        readings: []
                    };
                }
                
                // Adicionar leitura ao dispositivo
                sensorsDataByDevice[deviceKey].readings.push({
                    timestamp: reading.timestamp,
                    umidade_solo: reading.umidade_solo,
                    quantidade_chuva: reading.quantidade_chuva,
                    _id: reading._id
                });
            });
            
            // Ordenar leituras por timestamp e calcular status online
            Object.keys(sensorsDataByDevice).forEach(deviceKey => {
                const device = sensorsDataByDevice[deviceKey];
                
                // Ordenar leituras (mais antigas primeiro)
                device.readings.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                
                // Calcular se está online (última leitura há menos de 30 minutos)
                if (device.readings.length > 0) {
                    const lastReading = device.readings[device.readings.length - 1];
                    const timeDiff = Date.now() - new Date(lastReading.timestamp).getTime();
                    device.isOnline = timeDiff < 30 * 60 * 1000; // 30 minutos
                }
            });
        }
        
        function generateDeviceName(deviceKey) {
            // Extrair parte única do device_key para criar nomes mais amigáveis
            const shortKey = deviceKey.split('-')[1]?.substring(0, 8) || deviceKey.substring(0, 8);
            
            // Mapear para nomes mais descritivos baseados no hash
            const nameMap = {
                '629e6a68': { name: 'Sensor Principal', location: 'Estufa A - Setor 1' },
                'a54d6cad': { name: 'Sensor Secundário', location: 'Campo Externo B' }
            };
            
            return nameMap[shortKey] || {
                name: `Sensor ${shortKey.toUpperCase()}`,
                location: `Área ${shortKey.substring(0, 3).toUpperCase()}`
            };
        }
        
        function updateMultiSensorStatistics() {
            // Contar dispositivos online/offline
            const devices = Object.values(sensorsDataByDevice);
            const onlineDevices = devices.filter(d => d.isOnline).length;
            const totalDevices = devices.length;
            
            // Calcular umidade média de todos os sensores (última leitura de cada)
            let totalHumidity = 0;
            let readingCount = 0;
            
            devices.forEach(sensor => {
                const latestReading = sensor.readings[sensor.readings.length - 1];
                if (latestReading) {
                    totalHumidity += latestReading.umidade_solo;
                    readingCount++;
                }
            });
            
            const avgHumidity = readingCount > 0 ? totalHumidity / readingCount : 0;
            
            // Calcular chuva total do dia (última leitura de cada sensor, pois é valor acumulado)
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            let totalRainToday = 0;
            let totalReadingsToday = 0;
            
            devices.forEach(sensor => {
                const todayReadings = sensor.readings.filter(reading => 
                    new Date(reading.timestamp) >= today
                );
                
                // Pegar apenas a última leitura do dia (valor já é acumulado)
                if (todayReadings.length > 0) {
                    // Ordenar por timestamp (mais recente primeiro)
                    todayReadings.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                    totalRainToday += todayReadings[0].quantidade_chuva;
                }
                
                totalReadingsToday += todayReadings.length;
            });
            
            // Atualizar UI
            document.getElementById('deviceCount').textContent = `${onlineDevices}/${totalDevices}`;
            document.getElementById('avgHumidity').textContent = avgHumidity.toFixed(1) + '%';
            document.getElementById('totalRain').textContent = totalRainToday.toFixed(1) + 'mm';
            document.getElementById('readingCount').textContent = totalReadingsToday;
        }
        
        function updateMultiDeviceStatus() {
            const container = document.getElementById('deviceStatusContainer');
            
            if (Object.keys(sensorsDataByDevice).length === 0) {
                container.innerHTML = `
                    <div class="device-status">
                        <div class="status-dot offline"></div>
                        <div>
                            <strong>Nenhum dispositivo cadastrado</strong>
                            <p style="margin: 0; font-size: 0.875rem; color: var(--text-gray);">
                                Configure dispositivos para começar a receber dados
                            </p>
                        </div>
                    </div>
                `;
                return;
            }
            
            let html = '<div style="margin-bottom: var(--spacing-lg);"><h3 style="margin-bottom: var(--spacing-md); font-size: 1.125rem; color: var(--dark-gray);">Status dos Dispositivos</h3>';
            
            Object.entries(sensorsDataByDevice).forEach(([deviceKey, sensor]) => {
                const lastReading = sensor.readings[sensor.readings.length - 1];
                const lastTime = lastReading ? new Date(lastReading.timestamp) : null;
                
                html += `
                    <div class="device-status" style="margin-bottom: var(--spacing-sm);">
                        <div class="status-dot ${sensor.isOnline ? '' : 'offline'}"></div>
                        <div style="flex: 1;">
                            <strong>${sensor.name}</strong>
                            <p style="margin: 0; font-size: 0.875rem; color: var(--text-gray);">
                                ${sensor.location} • ${sensor.isOnline ? 'Online' : 'Offline'}
                                ${lastTime ? `• ${lastTime.toLocaleString('pt-BR', { 
                                    day: '2-digit', 
                                    month: '2-digit', 
                                    hour: '2-digit', 
                                    minute: '2-digit' 
                                })}` : '• Sem leituras'}
                            </p>
                        </div>
                        ${lastReading ? `
                            <div style="text-align: right; font-size: 0.875rem;">
                                <div style="font-weight: 600; color: var(--dark-gray);">${lastReading.umidade_solo.toFixed(1)}%</div>
                                <div style="color: var(--text-gray); font-size: 0.75rem;">Umidade Solo</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            });
            
            html += '</div>';
            container.innerHTML = html;
        }
        
        function updateLatestReadings() {
            const container = document.getElementById('latestReadings');
            
            if (Object.keys(sensorsDataByDevice).length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <i class="fas fa-chart-line"></i>
                        <h4>Nenhuma leitura disponível</h4>
                        <p>Os dados dos sensores aparecerão aqui quando disponíveis</p>
                    </div>
                `;
                return;
            }
            
            // Coletar últimas leituras de todos os sensores
            let allReadings = [];
            
            Object.entries(sensorsDataByDevice).forEach(([deviceKey, sensor]) => {
                // Pegar últimas 3 leituras de cada sensor
                const recentReadings = sensor.readings.slice(-3).reverse();
                
                recentReadings.forEach(reading => {
                    allReadings.push({
                        ...reading,
                        deviceName: sensor.name,
                        deviceLocation: sensor.location,
                        deviceKey: deviceKey
                    });
                });
            });
            
            // Ordenar por timestamp (mais recentes primeiro)
            allReadings.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            
            // Mostrar apenas os 10 mais recentes
            const recentReadings = allReadings.slice(0, 10);
            
            let html = '';
            recentReadings.forEach(reading => {
                const timestamp = new Date(reading.timestamp);
                const formattedTime = timestamp.toLocaleString('pt-BR', {
                    day: '2-digit',
                    month: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                
                html += `
                    <div class="reading-item">
                        <div class="reading-info">
                            <div class="reading-icon humidity">
                                <i class="fas fa-thermometer-half"></i>
                            </div>
                            <div class="reading-details">
                                <h6>Umidade do Solo</h6>
                                <p>${reading.deviceName} - ${reading.deviceLocation}</p>
                            </div>
                        </div>
                        <div class="reading-values">
                            <div class="reading-value">${reading.umidade_solo.toFixed(1)}%</div>
                            <div class="reading-time">${formattedTime}</div>
                        </div>
                    </div>
                    <div class="reading-item">
                        <div class="reading-info">
                            <div class="reading-icon rain">
                                <i class="fas fa-cloud-rain"></i>
                            </div>
                            <div class="reading-details">
                                <h6>Quantidade de Chuva</h6>
                                <p>${reading.deviceName} - Pluviômetro</p>
                            </div>
                        </div>
                        <div class="reading-values">
                            <div class="reading-value">${reading.quantidade_chuva.toFixed(1)}mm</div>
                            <div class="reading-time">${formattedTime}</div>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        function initializeCharts() {
            // Configuração comum dos gráficos
            Chart.defaults.font.family = 'Inter, sans-serif';
            Chart.defaults.color = '#4a5568';
            
            // Gráfico de Umidade
            const humidityCtx = document.getElementById('humidityChart').getContext('2d');
            humidityChart = new Chart(humidityCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Umidade do Solo (%)',
                        data: [],
                        borderColor: '#3182ce',
                        backgroundColor: 'rgba(49, 130, 206, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    layout: {
                        padding: {
                            top: 10,
                            bottom: 30,
                            left: 10,
                            right: 10
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: {
                                usePointStyle: true,
                                padding: 20,
                                font: {
                                    size: 12,
                                    family: 'Inter, sans-serif'
                                }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0,0,0,0.8)',
                            titleColor: 'white',
                            bodyColor: 'white'
                        },
                        zoom: {
                            zoom: {
                                wheel: {
                                    enabled: true
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'x'
                            },
                            pan: {
                                enabled: true,
                                mode: 'x'
                            },
                            limits: {
                                x: {min: 'original', max: 'original'}
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                }
                            }
                        },
                        x: {
                            display: true
                        }
                    },
                    elements: {
                        point: {
                            radius: 3,
                            hoverRadius: 6
                        }
                    }
                }
            });
            
            // Gráfico de Chuva
            const rainCtx = document.getElementById('rainChart').getContext('2d');
            rainChart = new Chart(rainCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Quantidade de Chuva (mm)',
                        data: [],
                        borderColor: '#7fb069',
                        backgroundColor: 'rgba(127, 176, 105, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    layout: {
                        padding: {
                            top: 10,
                            bottom: 30,
                            left: 10,
                            right: 10
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: {
                                usePointStyle: true,
                                padding: 20,
                                font: {
                                    size: 12,
                                    family: 'Inter, sans-serif'
                                }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0,0,0,0.8)',
                            titleColor: 'white',
                            bodyColor: 'white'
                        },
                        zoom: {
                            zoom: {
                                wheel: {
                                    enabled: true
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'x'
                            },
                            pan: {
                                enabled: true,
                                mode: 'x'
                            },
                            limits: {
                                x: {min: 'original', max: 'original'}
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return value + 'mm';
                                }
                            }
                        },
                        x: {
                            display: true
                        }
                    },
                    elements: {
                        point: {
                            radius: 3,
                            hoverRadius: 6
                        }
                    }
                }
            });
            
            // Aplicar preferências salvas do localStorage aos gráficos recém-criados
            loadChartPreferences();
            
            updateCharts();
        }
        
        function updateCharts() {
            updateHumidityChart();
            updateRainChart();
        }
        
        async function updateHumidityChart() {
            // Verificar se o gráfico foi inicializado
            if (!humidityChart) {
                console.warn('Gráfico de umidade não foi inicializado ainda');
                return;
            }
            
            const filter = document.getElementById('humidityFilter').value;
            const colors = [
                '#3182ce', '#38a169', '#e53e3e', '#f6ad55', 
                '#9f7aea', '#00d9ff', '#ff6b6b', '#4ecdc4'
            ];
            
            try {
                // Carregar dados da API com filtro de período
                const companyId = window.adminViewCompanyId || adminCompanyId || AuthManager.getCompanyId();
                // Se filter for "all", não enviar o parâmetro period
                const period = filter === 'all' ? null : filter;
                const response = await ApiClient.getSensorsHistory(companyId, period);
                
                // Extrair array de dados da resposta da API
                const historyData = response?.dados || response || [];
                
                // Processar dados para o gráfico
                if (!historyData || historyData.length === 0) {
                    humidityChart.data.labels = [];
                    humidityChart.data.datasets = [];
                    humidityChart.update();
                    return;
                }
                
                // Agrupar dados por device_key
                const dataByDevice = {};
                historyData.forEach(reading => {
                    const deviceKey = reading.device_key;
                    if (!dataByDevice[deviceKey]) {
                        dataByDevice[deviceKey] = {
                            name: sensorsDataByDevice[deviceKey]?.name || generateDeviceName(deviceKey).name,
                            location: sensorsDataByDevice[deviceKey]?.location || generateDeviceName(deviceKey).location,
                            readings: []
                        };
                    }
                    dataByDevice[deviceKey].readings.push(reading);
                });
                
                // Coletar todos os timestamps únicos
                let allTimestamps = new Set();
                Object.values(dataByDevice).forEach(sensor => {
                    sensor.readings.forEach(reading => {
                        allTimestamps.add(reading.timestamp);
                    });
                });
                
                // Converter para array ordenado
                const timestamps = Array.from(allTimestamps).sort();
                
                // Criar labels para o eixo X
                humidityChart.data.labels = timestamps.map(timestamp => {
                    const date = new Date(timestamp);
                    if (filter === '24h') {
                        // Mostrar dia e hora para evitar ambiguidade quando há dados de múltiplos dias
                        return date.toLocaleString('pt-BR', { 
                            day: '2-digit', 
                            month: '2-digit',
                            hour: '2-digit', 
                            minute: '2-digit' 
                        });
                    } else if (filter === 'all') {
                        return date.toLocaleDateString('pt-BR', { day: '2-digit', month: 'short', year: '2-digit' });
                    } else {
                        return date.toLocaleDateString('pt-BR', { month: 'short', day: '2-digit' });
                    }
                });
                
                // Limpar datasets anteriores
                humidityChart.data.datasets = [];
                
                // Criar dataset para cada sensor
                let colorIndex = 0;
                Object.entries(dataByDevice).forEach(([deviceKey, sensor]) => {
                    // Criar array de dados alinhado com os timestamps
                    const data = timestamps.map(timestamp => {
                        const reading = sensor.readings.find(r => r.timestamp === timestamp);
                        return reading ? reading.umidade_solo : null;
                    });
                    
                    // Adicionar dataset para este sensor
                    humidityChart.data.datasets.push({
                        label: `${sensor.name} (${sensor.location})`,
                        data: data,
                        borderColor: colors[colorIndex % colors.length],
                        backgroundColor: colors[colorIndex % colors.length] + '20',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.4,
                        spanGaps: true,
                        pointRadius: 3,
                        pointHoverRadius: 6
                    });
                    
                    colorIndex++;
                });
                
                humidityChart.update();
                
            } catch (error) {
                console.error('Erro ao atualizar gráfico de umidade:', error);
                // Limpar gráfico em caso de erro
                humidityChart.data.labels = [];
                humidityChart.data.datasets = [];
                humidityChart.update();
            }
        }
        
        async function updateRainChart() {
            // Verificar se o gráfico foi inicializado
            if (!rainChart) {
                console.warn('Gráfico de chuva não foi inicializado ainda');
                return;
            }
            
            const filter = document.getElementById('rainFilter').value;
            const colors = [
                '#7fb069', '#38a169', '#2d5a27', '#68d391', 
                '#48bb78', '#22543d', '#9ae6b4', '#276749'
            ];
            
            try {
                // Carregar dados da API com filtro de período
                const companyId = window.adminViewCompanyId || adminCompanyId || AuthManager.getCompanyId();
                // Se filter for "all", não enviar o parâmetro period
                const period = filter === 'all' ? null : filter;
                const response = await ApiClient.getSensorsHistory(companyId, period);
                
                // Extrair array de dados da resposta da API
                const historyData = response?.dados || response || [];
                
                // Processar dados para o gráfico
                if (!historyData || historyData.length === 0) {
                    rainChart.data.labels = [];
                    rainChart.data.datasets = [];
                    rainChart.update();
                    return;
                }
                
                // Agrupar dados por device_key
                const dataByDevice = {};
                historyData.forEach(reading => {
                    const deviceKey = reading.device_key;
                    if (!dataByDevice[deviceKey]) {
                        const deviceName = generateDeviceName(deviceKey);
                        dataByDevice[deviceKey] = {
                            name: deviceName.name,
                            readings: []
                        };
                    }
                    dataByDevice[deviceKey].readings.push(reading);
                });
                
                // Coletar todos os timestamps únicos
                let allTimestamps = new Set();
                Object.values(dataByDevice).forEach(sensor => {
                    sensor.readings.forEach(reading => {
                        allTimestamps.add(reading.timestamp);
                    });
                });
                
                // Converter para array ordenado
                const timestamps = Array.from(allTimestamps).sort();
                
                // Criar labels para o eixo X
                rainChart.data.labels = timestamps.map(timestamp => {
                    const date = new Date(timestamp);
                    if (filter === '24h') {
                        return date.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
                    } else if (filter === '7d') {
                        return date.toLocaleDateString('pt-BR', { weekday: 'short', day: '2-digit', month: 'short' });
                    } else if (filter === '30d') {
                        return date.toLocaleDateString('pt-BR', { day: '2-digit', month: 'short' });
                    } else if (filter === 'all') {
                        return date.toLocaleDateString('pt-BR', { day: '2-digit', month: 'short', year: '2-digit' });
                    } else {
                        return date.toLocaleDateString('pt-BR', { day: '2-digit', month: 'short' });
                    }
                });
                
                // Limpar datasets anteriores
                rainChart.data.datasets = [];
                
                // Criar dataset para cada sensor
                let colorIndex = 0;
                Object.entries(dataByDevice).forEach(([deviceKey, sensor]) => {
                    // Criar array de dados alinhado com os timestamps
                    const data = timestamps.map(timestamp => {
                        const reading = sensor.readings.find(r => r.timestamp === timestamp);
                        return reading ? reading.quantidade_chuva : null;
                    });
                    
                    // Adicionar dataset para este sensor
                    rainChart.data.datasets.push({
                        label: sensor.name,
                        data: data,
                        borderColor: colors[colorIndex % colors.length],
                        backgroundColor: colors[colorIndex % colors.length] + '20',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 3,
                        pointHoverRadius: 6
                    });
                    
                    colorIndex++;
                });
                
                rainChart.update();
                
            } catch (error) {
                console.error('Erro ao atualizar gráfico de chuva:', error);
                // Limpar gráfico em caso de erro
                rainChart.data.labels = [];
                rainChart.data.datasets = [];
                rainChart.update();
            }
        }
        
        function groupReadingsByTimePeriod(readings, filter) {
            const groups = {};
            
            readings.forEach(reading => {
                const date = new Date(reading.timestamp);
                let key;
                
                if (filter === '24h') {
                    // Agrupar por hora
                    key = `${date.getHours().toString().padStart(2, '0')}:00`;
                } else if (filter === '7d') {
                    // Agrupar por dia
                    key = date.toLocaleDateString('pt-BR', { weekday: 'short', day: '2-digit' });
                } else if (filter === '30d') {
                    // Agrupar por dia
                    key = date.toLocaleDateString('pt-BR', { month: 'short', day: '2-digit' });
                } else if (filter === 'all') {
                    // Agrupar por semana
                    const weekStart = new Date(date);
                    weekStart.setDate(date.getDate() - date.getDay());
                    key = weekStart.toLocaleDateString('pt-BR', { month: 'short', day: '2-digit', year: '2-digit' });
                } else {
                    // Default: agrupar por dia
                    key = date.toLocaleDateString('pt-BR', { month: 'short', day: '2-digit' });
                }
                
                if (!groups[key]) {
                    groups[key] = {
                        byDevice: {}
                    };
                }
                
                // Agrupar por device_key para evitar somar leituras duplicadas do mesmo sensor
                const deviceKey = reading.device_key;
                if (!groups[key].byDevice[deviceKey]) {
                    groups[key].byDevice[deviceKey] = [];
                }
                groups[key].byDevice[deviceKey].push({
                    timestamp: new Date(reading.timestamp),
                    rain: reading.quantidade_chuva
                });
            });
            
            // Converter para arrays ordenados
            const sortedKeys = Object.keys(groups).sort();
            const labels = sortedKeys;
            const totalRain = sortedKeys.map(key => {
                let periodTotal = 0;
                
                // Para cada dispositivo no período, pegar apenas a última leitura (valor acumulado)
                Object.values(groups[key].byDevice).forEach(deviceReadings => {
                    // Ordenar por timestamp
                    deviceReadings.sort((a, b) => b.timestamp - a.timestamp);
                    // Pegar a última leitura (mais recente) que já vem com valor acumulado
                    if (deviceReadings.length > 0) {
                        periodTotal += deviceReadings[0].rain;
                    }
                });
                
                return periodTotal;
            });
            
            return { labels, totalRain };
        }
        
        function filterDataByTime(data, filter) {
            // Se filter for "all", retornar todos os dados
            if (filter === 'all') {
                return data;
            }
            
            const now = new Date();
            let cutoff;
            
            switch (filter) {
                case '24h':
                    cutoff = new Date(now.getTime() - 24 * 60 * 60 * 1000);
                    break;
                case '7d':
                    cutoff = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                    break;
                case '30d':
                    cutoff = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                    break;
                default:
                    cutoff = new Date(now.getTime() - 24 * 60 * 60 * 1000);
            }
            
            return data.filter(item => new Date(item.timestamp) >= cutoff);
        }
        
        function setupEventListeners() {
            // Logout (com verificação de segurança)
            const logoutBtn = document.getElementById('logoutBtn');
            if (logoutBtn) {
                logoutBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    if (typeof AuthManager !== 'undefined' && AuthManager.logout) {
                        AuthManager.logout();
                    } else {
                        // Fallback se AuthManager não estiver disponível
                        window.location.href = '../index.html';
                    }
                });
            }
            
            // Atualização automática a cada intervalo configurado (padrão: 5 minutos)
            if (typeof loadDashboardData === 'function') {
                // Carregar intervalo do localStorage ou usar 5 minutos como padrão
                const savedInterval = localStorage.getItem('dashboardRefreshInterval');
                const refreshInterval = savedInterval ? parseInt(savedInterval) : 5 * 60 * 1000;
                
                console.log(`Dashboard será atualizado automaticamente a cada ${refreshInterval}ms (${refreshInterval / 60000} minutos)`);
                
                setInterval(loadDashboardData, refreshInterval);
            }
            
            // Fechar dropdowns ao clicar fora
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.chart-control-btn') && !e.target.closest('.chart-settings-dropdown')) {
                    document.querySelectorAll('.chart-settings-dropdown').forEach(dropdown => {
                        dropdown.classList.remove('show');
                    });
                }
            });
            
            // Nota: loadChartPreferences() agora é chamada em initializeCharts()
            // após a criação dos gráficos, não aqui
        }
        
        // ===== FUNÇÕES DE PERSONALIZAÇÃO DE GRÁFICOS =====
        
        // Armazenamento de configurações
        const chartConfigs = {
            humidity: {
                type: 'line',
                showGrid: true,
                showPoints: true,
                fill: true
            },
            rain: {
                type: 'line',
                showGrid: true,
                showPoints: true,
                fill: true
            }
        };
        
        // Toggle do menu de configurações
        function toggleChartSettings(chartName) {
            const dropdown = document.getElementById(`${chartName}Settings`);
            const allDropdowns = document.querySelectorAll('.chart-settings-dropdown');
            
            // Fechar outros dropdowns
            allDropdowns.forEach(d => {
                if (d !== dropdown) {
                    d.classList.remove('show');
                }
            });
            
            // Toggle do dropdown atual
            dropdown.classList.toggle('show');
            
            console.log(`Toggle dropdown ${chartName}:`, dropdown.classList.contains('show') ? 'ABERTO' : 'FECHADO');
        }
        
        // Mudar tipo de gráfico
        function changeChartType(chartName, type) {
            console.log(`Mudando tipo de gráfico ${chartName} para:`, type);
            
            // Atualizar configuração
            chartConfigs[chartName].type = type;
            
            // Atualizar UI dos botões
            const container = document.getElementById(`${chartName}Settings`);
            container.querySelectorAll('.chart-type-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.type === type) {
                    btn.classList.add('active');
                }
            });
            
            // Aplicar mudança ao gráfico
            const chart = chartName === 'humidity' ? humidityChart : rainChart;
            
            if (!chart) {
                console.warn(`Gráfico ${chartName} não encontrado`);
                return;
            }
            
            if (type === 'area') {
                // Área é linha com fill
                chart.config.type = 'line';
                if (chart.data && chart.data.datasets) {
                    chart.data.datasets.forEach(dataset => {
                        dataset.fill = true;
                        dataset.backgroundColor = dataset.borderColor + '33';
                    });
                }
            } else if (type === 'bar') {
                chart.config.type = 'bar';
                if (chart.data && chart.data.datasets) {
                    chart.data.datasets.forEach(dataset => {
                        dataset.fill = false;
                    });
                }
            } else {
                // Linha
                chart.config.type = 'line';
                if (chart.data && chart.data.datasets) {
                    chart.data.datasets.forEach(dataset => {
                        dataset.fill = chartConfigs[chartName].fill;
                    });
                }
            }
            
            chart.update();
            console.log(`Gráfico ${chartName} atualizado para tipo:`, type);
            saveChartPreferences();
        }
        
        // Toggle grid
        function toggleChartGrid(chartName) {
            const toggle = document.getElementById(`${chartName}GridToggle`);
            const isActive = toggle.classList.toggle('active');
            chartConfigs[chartName].showGrid = isActive;
            
            const chart = chartName === 'humidity' ? humidityChart : rainChart;
            if (chart && chart.options && chart.options.scales) {
                chart.options.scales.x.grid = { display: isActive };
                chart.options.scales.y.grid = { display: isActive };
                chart.update();
            }
            
            console.log(`Grid ${chartName}:`, isActive ? 'ATIVADO' : 'DESATIVADO');
            saveChartPreferences();
        }
        
        // Toggle pontos
        function toggleChartPoints(chartName) {
            const toggle = document.getElementById(`${chartName}PointsToggle`);
            const isActive = toggle.classList.toggle('active');
            chartConfigs[chartName].showPoints = isActive;
            
            const chart = chartName === 'humidity' ? humidityChart : rainChart;
            if (chart && chart.data && chart.data.datasets) {
                chart.data.datasets.forEach(dataset => {
                    dataset.pointRadius = isActive ? 3 : 0;
                    dataset.pointHoverRadius = isActive ? 6 : 0;
                });
                chart.update();
            }
            
            console.log(`Pontos ${chartName}:`, isActive ? 'ATIVADO' : 'DESATIVADO');
            saveChartPreferences();
        }
        
        // Toggle preenchimento
        function toggleChartFill(chartName) {
            const toggle = document.getElementById(`${chartName}FillToggle`);
            const isActive = toggle.classList.toggle('active');
            chartConfigs[chartName].fill = isActive;
            
            const chart = chartName === 'humidity' ? humidityChart : rainChart;
            if (chart && chart.config && chart.config.type === 'line' && chart.data && chart.data.datasets) {
                chart.data.datasets.forEach(dataset => {
                    dataset.fill = isActive;
                    if (isActive) {
                        dataset.backgroundColor = dataset.borderColor + '20';
                    } else {
                        dataset.backgroundColor = 'transparent';
                    }
                });
                chart.update();
            }
            
            console.log(`Preenchimento ${chartName}:`, isActive ? 'ATIVADO' : 'DESATIVADO');
            saveChartPreferences();
        }
        
        // Salvar preferências no localStorage
        function saveChartPreferences() {
            try {
                localStorage.setItem('chartPreferences', JSON.stringify(chartConfigs));
            } catch (error) {
                console.warn('Erro ao salvar preferências:', error);
            }
        }
        
        // Carregar preferências do localStorage
        function loadChartPreferences() {
            try {
                const saved = localStorage.getItem('chartPreferences');
                if (saved) {
                    const preferences = JSON.parse(saved);
                    Object.assign(chartConfigs, preferences);
                }
                
                // SEMPRE aplicar estados visuais (mesmo sem localStorage salvo)
                ['humidity', 'rain'].forEach(chartName => {
                    const config = chartConfigs[chartName];
                    
                    // Atualizar toggles visuais
                    const gridToggle = document.getElementById(`${chartName}GridToggle`);
                    const pointsToggle = document.getElementById(`${chartName}PointsToggle`);
                    const fillToggle = document.getElementById(`${chartName}FillToggle`);
                    
                    if (gridToggle) {
                        if (config.showGrid) {
                            gridToggle.classList.add('active');
                        } else {
                            gridToggle.classList.remove('active');
                        }
                    }
                    
                    if (pointsToggle) {
                        if (config.showPoints) {
                            pointsToggle.classList.add('active');
                        } else {
                            pointsToggle.classList.remove('active');
                        }
                    }
                    
                    if (fillToggle) {
                        if (config.fill) {
                            fillToggle.classList.add('active');
                        } else {
                            fillToggle.classList.remove('active');
                        }
                    }
                    
                    // Atualizar botão de tipo
                    const typeButtons = document.querySelectorAll(`#${chartName}Settings .chart-type-btn`);
                    typeButtons.forEach(btn => {
                        if (btn.dataset.type === config.type) {
                            btn.classList.add('active');
                        } else {
                            btn.classList.remove('active');
                        }
                    });
                });
                
                console.log('Preferências de gráficos carregadas:', chartConfigs);
                
                // Aplicar preferências aos gráficos Chart.js
                applyChartPreferencesToCharts();
            } catch (error) {
                console.warn('Erro ao carregar preferências:', error);
            }
        }
        
        // Aplicar configurações salvas aos objetos Chart.js
        function applyChartPreferencesToCharts() {
            ['humidity', 'rain'].forEach(chartName => {
                const chart = chartName === 'humidity' ? humidityChart : rainChart;
                const config = chartConfigs[chartName];
                
                if (!chart) {
                    console.warn(`Gráfico ${chartName} ainda não foi inicializado`);
                    return;
                }
                
                // Aplicar tipo de gráfico
                if (config.type === 'area') {
                    chart.config.type = 'line';
                    if (chart.data && chart.data.datasets) {
                        chart.data.datasets.forEach(dataset => {
                            dataset.fill = true;
                        });
                    }
                } else if (config.type === 'bar') {
                    chart.config.type = 'bar';
                    if (chart.data && chart.data.datasets) {
                        chart.data.datasets.forEach(dataset => {
                            dataset.fill = false;
                        });
                    }
                } else {
                    // line
                    chart.config.type = 'line';
                    if (chart.data && chart.data.datasets) {
                        chart.data.datasets.forEach(dataset => {
                            dataset.fill = config.fill;
                        });
                    }
                }
                
                // Aplicar grid
                if (chart.options && chart.options.scales) {
                    chart.options.scales.x.grid = { display: config.showGrid };
                    chart.options.scales.y.grid = { display: config.showGrid };
                }
                
                // Aplicar pontos
                if (chart.data && chart.data.datasets) {
                    chart.data.datasets.forEach(dataset => {
                        dataset.pointRadius = config.showPoints ? 3 : 0;
                        dataset.pointHoverRadius = config.showPoints ? 6 : 0;
                    });
                }
                
                // Aplicar preenchimento
                if (chart.config.type === 'line' && chart.data && chart.data.datasets) {
                    chart.data.datasets.forEach(dataset => {
                        dataset.fill = config.fill;
                    });
                }
                
                chart.update();
            });
            
            console.log('Preferências aplicadas aos gráficos Chart.js');
        }
        
        function setupMobileMenu() {
            try {
                const sidebarToggle = document.querySelector('[data-sidebar-toggle]');
                const sidebar = document.querySelector('.sidebar');
                const overlay = document.querySelector('[data-sidebar-overlay]');
                
                if (!sidebarToggle || !sidebar || !overlay) {
                    return;
                }
                
                // Configurar estado inicial do sidebar
                initializeSidebarState();
                
                // Toggle sidebar ao clicar no hamburguer
                sidebarToggle.addEventListener('click', function(e) {
                    e.preventDefault();
                    toggleSidebar();
                });
                
                // Fechar sidebar ao clicar no overlay
                overlay.addEventListener('click', function() {
                    if (sidebarAberto) fecharSidebar();
                });
                
                // Fechar sidebar com ESC
                document.addEventListener('keydown', function(e) {
                    if (e.key === 'Escape' && sidebarAberto) {
                        fecharSidebar();
                    }
                });
                
                // Fechar sidebar ao clicar em links (mobile)
                if (window.innerWidth <= 1024) {
                    const sidebarLinks = sidebar.querySelectorAll('.sidebar-nav-link:not(.disabled)');
                    sidebarLinks.forEach(link => {
                        link.addEventListener('click', function() {
                            if (sidebarAberto) {
                                setTimeout(() => fecharSidebar(), 150);
                            }
                        });
                    });
                }
            } catch (error) {
                // Silencioso - menu mobile não crítico
            }
        }
        
        function initializeSidebarState() {
            const sidebar = document.querySelector('.sidebar');
            const overlay = document.querySelector('[data-sidebar-overlay]');
            
            if (!sidebar || !overlay) return;
            
            // FORÇAR estado inicial fechado COMPLETAMENTE
            sidebarAberto = false;
            
            if (window.innerWidth <= 1024) {
                // FORÇAR sidebar para FORA da tela
                sidebar.style.cssText = `
                    position: fixed !important;
                    left: -300px !important;
                    top: 0 !important;
                    width: 280px !important;
                    height: 100vh !important;
                    z-index: -1 !important;
                    transform: translateX(-100%) !important;
                `;
                
                overlay.style.cssText = `
                    opacity: 0 !important;
                    visibility: hidden !important;
                    pointer-events: none !important;
                    z-index: -1 !important;
                `;
            }
            

        }
        
        // Variável simples para controlar estado
        let sidebarAberto = false;
        
        function toggleSidebar() {
            if (sidebarAberto) {
                fecharSidebar();
            } else {
                abrirSidebar();
            }
        }
        
        function abrirSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const overlay = document.querySelector('[data-sidebar-overlay]');
            const hamburger = document.querySelector('[data-sidebar-toggle]');
            
            // Forçar estilos inline - SIMPLES E DIRETO
            sidebar.style.cssText = `
                position: fixed !important;
                left: 0 !important;
                top: 0 !important;
                width: 280px !important;
                height: 100vh !important;
                z-index: 9999 !important;
                background: white !important;
                transform: translateX(0) !important;
                transition: transform 0.3s ease !important;
                box-shadow: 0 0 30px rgba(0,0,0,0.5) !important;
            `;
            
            overlay.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                width: 100% !important;
                height: 100% !important;
                background: rgba(0,0,0,0.5) !important;
                z-index: 998 !important;
                opacity: 1 !important;
                visibility: visible !important;
                pointer-events: auto !important;
            `;
            
            hamburger.classList.add('active');
            document.body.style.overflow = 'hidden';
            sidebarAberto = true;
        }
        
        function fecharSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const overlay = document.querySelector('[data-sidebar-overlay]');
            const hamburger = document.querySelector('[data-sidebar-toggle]');
            
            // FORÇAR COMPLETAMENTE O FECHAMENTO
            sidebar.style.cssText = `
                position: fixed !important;
                left: -300px !important;
                top: 0 !important;
                width: 280px !important;
                height: 100vh !important;
                z-index: -1 !important;
                transform: translateX(-100%) !important;
                transition: all 0.3s ease !important;
            `;
            
            overlay.style.cssText = `
                opacity: 0 !important;
                visibility: hidden !important;
                pointer-events: none !important;
                z-index: -1 !important;
            `;
            
            hamburger.classList.remove('active');
            document.body.style.overflow = '';
            sidebarAberto = false;
        }
        
        // Gerenciar responsividade  
        function handleResize() {
            // Se mudou para desktop, fechar sidebar
            if (window.innerWidth > 1024 && sidebarAberto) {
                fecharSidebar();
            }
            
            // Reinicializar estado
            initializeSidebarState();
        }
        
        // Debounce para otimizar performance
        let resizeTimeout;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(handleResize, 150);
        });
        
        // Executar uma vez no carregamento
        handleResize();

    </script>
</body>
</html>