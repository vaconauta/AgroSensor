<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard - WR10</title>
    
    <!-- Desabilitar Cache Completamente -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <!-- Fontes -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    
    <!-- CSS -->
    <link rel="stylesheet" href="../assets/css/style.css">
    
    <!-- Router para navegação otimizada -->
    <script src="../assets/js/router.js"></script>
    
    <style>
        /* Prevenir overflow horizontal global */
        body, html {
            overflow-x: hidden;
            max-width: 100%;
        }
        
        .main-content {
            overflow-x: hidden;
            max-width: 100%;
        }
        
        .content-body {
            overflow-x: hidden;
            max-width: 100%;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: var(--spacing-lg);
            margin-bottom: var(--spacing-xl);
            align-items: start;
            grid-auto-rows: min-content;
        }
        
        /* Ajustes para tablets */
        @media (max-width: 768px) {
            .stats-grid {
                grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
                gap: var(--spacing-md);
                margin-bottom: var(--spacing-lg);
            }
        }
        
        /* Ajustes para mobile */
        @media (max-width: 480px) {
            .stats-grid {
                grid-template-columns: 1fr;
                gap: var(--spacing-sm);
                margin-bottom: var(--spacing-md);
            }
        }
        
        .chart-container {
            position: relative;
            height: 450px;
            background: var(--white);
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
            border: 1px solid var(--border-gray);
            box-shadow: var(--shadow-sm);
            overflow: visible;
        }
        
        @media (max-width: 768px) {
            .chart-container {
                overflow-x: hidden;
                padding: var(--spacing-md);
            }
        }
        
        @media (max-width: 480px) {
            .chart-container {
                padding: var(--spacing-sm);
            }
        }
        
        .chart-container canvas {
            max-height: 360px !important;
            width: 100% !important;
            height: 360px !important;
            display: block;
            box-sizing: border-box;
        }
        
        /* Melhorar espaçamento entre elementos dos gráficos */
        .chart-header {
            flex-shrink: 0;
            min-height: 60px;
        }
        
        .chart-title {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 200px;
        }
        
        .filter-selector {
            min-width: 120px;
            flex-shrink: 0;
        }
        
        /* Garantir que não há overflow ou sobreposição */
        .dashboard-content * {
            box-sizing: border-box;
        }
        
        /* Melhor controle de texto nos gráficos */
        .chart-container .chartjs-tooltip {
            z-index: 1000 !important;
        }
        
        /* Canvas não deve bloquear cliques nos botões */
        .chart-container canvas {
            position: relative;
            z-index: 1;
        }
        
        /* Header e controles devem ficar acima do canvas */
        .chart-header {
            position: relative;
            z-index: 10;
        }
        
        .chart-settings-dropdown {
            z-index: 1001 !important;
        }
        
        /* Evitar sobreposição de elementos */
        .col-4 {
            min-width: 0;
            overflow: hidden;
        }
        
        /* Links desabilitados */
        .sidebar-nav-link.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
            position: relative;
        }
        
        .sidebar-nav-link.disabled::after {
            content: "Em breve";
            position: absolute;
            right: 12px;
            font-size: 0.75rem;
            background: var(--text-gray);
            color: var(--white);
            padding: 2px 6px;
            border-radius: 10px;
        }
        
        .chart-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--spacing-lg);
            padding-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--border-gray);
            gap: var(--spacing-md);
            flex-wrap: wrap;
            position: relative;
        }
        
        .chart-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--dark-gray);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            white-space: nowrap;
            flex-shrink: 0;
            margin: 0;
        }
        
        .chart-title i {
            flex-shrink: 0;
        }
        
        .chart-actions {
            display: flex;
            gap: var(--spacing-sm);
            flex-shrink: 0;
            position: relative;
        }
        
        .filter-selector {
            padding: var(--spacing-xs) var(--spacing-sm);
            border: 1px solid var(--border-gray);
            border-radius: var(--radius-md);
            font-size: 0.875rem;
            background: var(--white);
            cursor: pointer;
            min-width: 130px;
            flex-shrink: 0;
        }
        
        /* Botões de controle de gráfico */
        .chart-control-btn {
            padding: var(--spacing-xs) var(--spacing-sm);
            border: 1px solid var(--border-gray);
            border-radius: var(--radius-md);
            background: var(--white);
            cursor: pointer;
            font-size: 0.875rem;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            transition: var(--transition);
            color: var(--dark-gray);
            white-space: nowrap;
        }
        
        .chart-control-btn:hover {
            background: var(--light-gray);
            border-color: #3182ce;
            color: #3182ce;
        }
        
        .chart-control-btn.active {
            background: #3182ce;
            color: var(--white);
            border-color: #3182ce;
        }
        
        .chart-control-btn i {
            font-size: 0.875rem;
        }
        
        /* Ajustes para botões em mobile */
        @media (max-width: 768px) {
            .chart-control-btn {
                padding: var(--spacing-xs);
                font-size: 0.8rem;
                gap: 4px;
            }
            
            .chart-control-btn i {
                font-size: 0.8rem;
            }
        }
        
        @media (max-width: 480px) {
            .chart-control-btn {
                padding: 6px 8px;
                font-size: 0.75rem;
            }
            
            .chart-control-btn span {
                display: none; /* Ocultar texto, mostrar apenas ícone */
            }
            
            .chart-control-btn i {
                font-size: 0.9rem;
                margin: 0;
            }
        }
        
        /* Dropdown de personalização */
        .chart-settings-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 8px;
            background: var(--white);
            border: 1px solid var(--border-gray);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-lg);
            padding: var(--spacing-md);
            min-width: 250px;
            max-width: 90vw;
            z-index: 1000;
            display: none;
        }
        
        .chart-settings-dropdown.show {
            display: block;
        }
        
        /* Ajustar dropdown em mobile para não causar overflow */
        @media (max-width: 768px) {
            .chart-settings-dropdown {
                position: absolute;
                right: 10px;
                left: auto;
                top: 100%;
                min-width: 240px;
                max-width: calc(100vw - 40px);
                transform: none;
                margin-top: 8px;
            }
            
            /* Garantir que o container de ações seja o contexto de posicionamento */
            .chart-header {
                position: relative;
            }
        }
        
        @media (max-width: 480px) {
            .chart-settings-dropdown {
                min-width: 220px;
                max-width: calc(100vw - 30px);
                padding: var(--spacing-sm);
                right: 5px;
            }
        }
        
        .chart-settings-section {
            margin-bottom: var(--spacing-md);
        }
        
        .chart-settings-section:last-child {
            margin-bottom: 0;
        }
        
        .chart-settings-label {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--dark-gray);
            margin-bottom: var(--spacing-xs);
            display: block;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .chart-type-buttons {
            display: flex;
            gap: var(--spacing-xs);
        }
        
        .chart-type-btn {
            flex: 1;
            padding: var(--spacing-xs);
            border: 1px solid var(--border-gray);
            border-radius: var(--radius-sm);
            background: var(--white);
            cursor: pointer;
            font-size: 0.75rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            transition: var(--transition);
            color: var(--text-gray);
        }
        
        .chart-type-btn:hover {
            background: var(--light-gray);
            border-color: #3182ce;
        }
        
        .chart-type-btn.active {
            background: #3182ce;
            color: var(--white);
            border-color: #3182ce;
        }
        
        .chart-type-btn i {
            font-size: 1.25rem;
        }
        
        .chart-settings-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: var(--spacing-xs) 0;
            font-size: 0.875rem;
            color: var(--dark-gray);
        }
        
        .toggle-switch {
            position: relative;
            width: 40px;
            height: 20px;
            background: #cbd5e0;
            border-radius: 20px;
            cursor: pointer;
            transition: var(--transition);
        }
        
        .toggle-switch.active {
            background: #48bb78;
        }
        
        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: var(--white);
            border-radius: 50%;
            transition: var(--transition);
        }
        
        .toggle-switch.active::after {
            left: 22px;
        }
        
        /* Input de número para limite de registros */
        input[type="number"] {
            appearance: textfield;
            -moz-appearance: textfield;
        }
        
        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        input[type="number"]:focus {
            outline: none;
            border-color: #3182ce;
            box-shadow: 0 0 0 3px rgba(49, 130, 206, 0.1);
        }
        
        .no-data {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 300px;
            color: var(--text-gray);
            text-align: center;
        }
        
        .no-data i {
            font-size: 3rem;
            margin-bottom: var(--spacing-md);
            opacity: 0.5;
        }
        
        .device-status {
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-md);
            padding: var(--spacing-sm);
            background: var(--light-gray);
            border-radius: var(--radius-md);
            font-size: 0.875rem;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success);
        }
        
        .status-dot.offline {
            background: var(--error);
        }
        
        .latest-readings {
            background: var(--white);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border-gray);
            box-shadow: var(--shadow-sm);
        }
        
        .readings-header {
            padding: var(--spacing-lg);
            border-bottom: 1px solid var(--border-gray);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .readings-list {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .reading-item {
            padding: var(--spacing-md) var(--spacing-lg);
            border-bottom: 1px solid var(--border-gray);
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: var(--transition);
        }
        
        .reading-item:last-child {
            border-bottom: none;
        }
        
        .reading-item:hover {
            background: var(--light-gray);
        }
        
        .reading-info {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
        }
        
        .reading-icon {
            width: 40px;
            height: 40px;
            border-radius: var(--radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--white);
            font-size: 1.125rem;
        }
        
        .reading-icon.humidity {
            background: linear-gradient(135deg, var(--info), #63b3ed);
        }
        
        .reading-icon.rain {
            background: linear-gradient(135deg, var(--accent-green), var(--light-green));
        }
        
        .reading-details h6 {
            margin: 0 0 var(--spacing-xs) 0;
            font-weight: 600;
            color: var(--dark-gray);
        }
        
        .reading-details p {
            margin: 0;
            font-size: 0.875rem;
            color: var(--text-gray);
        }
        
        .reading-values {
            text-align: right;
        }
        
        .reading-value {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--dark-gray);
            margin-bottom: var(--spacing-xs);
        }
        
        .reading-time {
            font-size: 0.75rem;
            color: var(--text-gray);
        }
        
        .empty-state {
            padding: var(--spacing-2xl);
            text-align: center;
            color: var(--text-gray);
        }
        
        .empty-state i {
            font-size: 3rem;
            margin-bottom: var(--spacing-md);
            opacity: 0.5;
        }
        
        /* ===== CARD DE VENTO - ESTILO BÚSSOLA ===== */
        .wind-compass-card {
            position: relative;
            padding: var(--spacing-md) !important;
            min-height: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
        }
        
        .wind-compass-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }
        
        .wind-compass-container {
            position: relative;
            width: 120px;
            height: 120px;
            margin: 0 auto;
            margin-top: 8px;
        }
        
        .wind-compass {
            position: relative;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: linear-gradient(135deg, #e6f7ff 0%, #f0f9ff 100%);
            border: 2.5px solid #3182ce;
            box-shadow: 0 3px 10px rgba(49, 130, 206, 0.15),
                        inset 0 2px 6px rgba(49, 130, 206, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Direções cardinais */
        .wind-direction {
            position: absolute;
            font-size: 0.65rem;
            font-weight: 700;
            color: #2c5282;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
        }
        
        .wind-direction.north {
            top: 6px;
            left: 50%;
            transform: translateX(-50%);
            color: #2563eb;
            font-size: 0.75rem;
        }
        
        .wind-direction.south {
            bottom: 6px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .wind-direction.east {
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .wind-direction.west {
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .wind-direction.northeast {
            top: 15px;
            right: 15px;
            font-size: 0.55rem;
            opacity: 0.7;
        }
        
        .wind-direction.northwest {
            top: 15px;
            left: 15px;
            font-size: 0.55rem;
            opacity: 0.7;
        }
        
        .wind-direction.southeast {
            bottom: 15px;
            right: 15px;
            font-size: 0.55rem;
            opacity: 0.7;
        }
        
        .wind-direction.southwest {
            bottom: 15px;
            left: 15px;
            font-size: 0.55rem;
            opacity: 0.7;
        }
        
        /* Centro com velocidade */
        .wind-center {
            position: relative;
            z-index: 10;
            text-align: center;
            background: white;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
            border: 2px solid #e2e8f0;
        }
        
        .wind-speed {
            font-size: 1.25rem;
            font-weight: 700;
            color: #3182ce;
            line-height: 1;
            margin-bottom: 2px;
        }
        
        .wind-unit {
            font-size: 0.6rem;
            color: #64748b;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        
        /* Indicador de direção - Seta/Ponteiro */
        .wind-arrow {
            position: absolute;
            width: 4px;
            height: 45px;
            background: linear-gradient(180deg, #ef4444 0%, #dc2626 100%);
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            transform-origin: 50% 90%;
            filter: drop-shadow(0 3px 6px rgba(239, 68, 68, 0.4));
            z-index: 5;
            border-radius: 2px;
            /* Rotação para norte (0deg) por padrão */
            /* Será atualizada dinamicamente via JavaScript:
               N = 0deg, NE = 45deg, E = 90deg, SE = 135deg,
               S = 180deg, SW = 225deg, W = 270deg, NW = 315deg */
        }
        
        /* Ponta da seta - Triangulo vermelho */
        .wind-arrow::before {
            content: '';
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 16px solid #ef4444;
            filter: drop-shadow(0 2px 4px rgba(239, 68, 68, 0.3));
        }
        
        /* Base da seta - Circulo pequeno */
        .wind-arrow::after {
            content: '';
            position: absolute;
            bottom: -6px;
            left: 50%;
            transform: translateX(-50%);
            width: 12px;
            height: 12px;
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        /* Animação suave da seta quando mudar direção */
        .wind-arrow.animated {
            transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        /* Marcadores de direção (linhas) */
        .wind-marker {
            position: absolute;
            width: 1.5px;
            height: 10px;
            background: #cbd5e0;
            left: 50%;
            transform-origin: center;
        }
        
        .wind-marker.cardinal {
            height: 14px;
            width: 2.5px;
            background: #3182ce;
        }
        
        /* Badge "Em breve" */
        .coming-soon-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: linear-gradient(135deg, #f59e0b 0%, #f97316 100%);
            color: white;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.65rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            box-shadow: 0 2px 4px rgba(245, 158, 11, 0.3);
            animation: pulse-badge 2s infinite;
        }
        
        @keyframes pulse-badge {
            0%, 100% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.05);
                opacity: 0.9;
            }
        }
        
        /* Label do card de vento */
        .wind-label {
            margin-top: var(--spacing-sm);
            font-size: 0.8rem;
            color: #9ca3af;
            font-weight: 500;
            text-align: center;
            line-height: 1.3;
            opacity: 0.7;
        }
        
        /* Ajustes responsivos para o card de vento */
        @media (max-width: 768px) {
            .wind-compass-card {
                min-height: auto;
                padding: var(--spacing-sm) !important;
            }
            
            .wind-compass-container {
                width: 110px;
                height: 110px;
                margin-top: 6px;
            }
            
            .wind-center {
                width: 55px;
                height: 55px;
            }
            
            .wind-speed {
                font-size: 1.15rem;
            }
            
            .wind-label {
                font-size: 0.75rem;
            }
        }
        
        @media (max-width: 480px) {
            .wind-compass-card {
                min-height: auto;
                padding: var(--spacing-sm) !important;
            }
            
            .wind-compass-container {
                width: 100px;
                height: 100px;
                margin-top: 4px;
            }
            
            .wind-center {
                width: 50px;
                height: 50px;
            }
            
            .wind-speed {
                font-size: 1.1rem;
            }
            
            .wind-unit {
                font-size: 0.55rem;
            }
            
            .wind-direction {
                font-size: 0.6rem;
            }
            
            .wind-direction.north {
                font-size: 0.7rem;
            }
            
            .wind-label {
                font-size: 0.7rem;
                margin-top: 6px;
            }
        }
        
        /* ===== MENU HAMBURGUER ===== */
        .btn-hamburger {
            display: none;
            flex-direction: column;
            justify-content: space-around;
            width: 44px;
            height: 44px;
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 8px;
            border-radius: var(--radius-md);
            transition: var(--transition);
            position: relative;
        }
        
        .btn-hamburger:hover {
            background: var(--light-gray);
        }
        
        .btn-hamburger:active {
            background: var(--medium-gray);
        }
        
        .hamburger-line {
            display: block;
            height: 3px;
            width: 100%;
            background: var(--dark-gray);
            border-radius: 2px;
            transition: var(--transition);
            transform-origin: center;
        }
        
        /* Animação do hamburguer para X */
        .btn-hamburger.active .hamburger-line:nth-child(1) {
            transform: translateY(8px) rotate(45deg);
        }
        
        .btn-hamburger.active .hamburger-line:nth-child(2) {
            opacity: 0;
        }
        
        .btn-hamburger.active .hamburger-line:nth-child(3) {
            transform: translateY(-8px) rotate(-45deg);
        }
        
        /* Overlay para fechar sidebar ao clicar fora */
        .sidebar-overlay {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100% !important;
            height: 100% !important;
            background: rgba(0, 0, 0, 0.5) !important;
            z-index: 999 !important;
            opacity: 0 !important;
            visibility: hidden !important;
            transition: var(--transition) !important;
            pointer-events: none !important;
        }
        
        .sidebar-overlay.show {
            opacity: 1 !important;
            visibility: visible !important;
            pointer-events: auto !important;
        }
        
        /* Melhorias no sidebar para mobile */
        @media (max-width: 1024px) {
            .btn-hamburger {
                display: flex !important;
            }
            
            .sidebar {
                transform: translateX(-100%) !important;
                transition: transform 0.3s ease !important;
                z-index: 1001 !important;
                position: fixed !important;
            }
            
            .sidebar.show {
                transform: translateX(0) !important;
                box-shadow: var(--shadow-xl) !important;
            }
            
            .main-content {
                margin-left: 0 !important;
                transition: margin-left 0.3s ease !important;
            }
        }
        
        /* Regras adicionais para garantir funcionamento */
        @media (max-width: 1024px) {
            .sidebar {
                left: 0 !important;
                top: 0 !important;
                width: 280px !important;
                height: 100vh !important;
                background: var(--white) !important;
            }
        }
        
        /* Melhorias adicionais para telas muito pequenas */
        @media (max-width: 768px) {
            .content-header h1 {
                font-size: 1.5rem;
            }
            
            .content-header p {
                font-size: 0.875rem;
            }
            
            .btn-hamburger {
                width: 40px;
                height: 40px;
            }
        }
        
        /* CSS SIMPLIFICADO - só o essencial */
        @media (max-width: 1024px) {
            .btn-hamburger {
                display: flex !important;
                position: absolute !important;
                right: 20px !important;
                top: 20px !important;
                z-index: 100 !important;
            }
        }
        
        /* Garantir que o header tenha position relative */
        .content-header {
            position: relative !important;
        }
        
        /* MELHORIAS PARA GRÁFICOS EM DISPOSITIVOS MÓVEIS */
        
        /* Garantir que o layout de colunas funcione corretamente */
        .row {
            display: flex !important;
            gap: var(--spacing-lg) !important;
            margin-bottom: var(--spacing-lg) !important;
            max-width: 100% !important;
            overflow: visible !important;
        }
        
        .col-8 {
            flex: 2 !important;
            min-width: 0 !important;
            overflow: visible !important;
        }
        
        .col-6 {
            flex: 1 !important;
            min-width: 0 !important;
            overflow: visible !important;
        }
        
        .col-4 {
            flex: 1 !important;
            min-width: 0 !important;
            overflow: visible !important;
        }
        
        @media (max-width: 1024px) {
            /* Fazer gráficos ocuparem largura total em tablets */
            .row {
                flex-direction: column !important;
                gap: var(--spacing-md) !important;
            }
            
            .col-8, .col-6, .col-4 {
                width: 100% !important;
                max-width: 100% !important;
                flex: none !important;
            }
            
            /* Aumentar altura dos containers de gráfico em tablets */
            .chart-container {
                height: 500px !important;
                margin-bottom: var(--spacing-lg) !important;
            }
            
            .chart-container canvas {
                max-height: 400px !important;
                height: 400px !important;
            }
        }
        
        @media (max-width: 768px) {
            /* Otimizações específicas para smartphones */
            .chart-container {
                height: 450px !important;
                padding: var(--spacing-md) !important;
            }
            
            .chart-container canvas {
                max-height: 350px !important;
                height: 350px !important;
            }
            
            /* Melhorar header dos gráficos em mobile */
            .chart-header {
                flex-direction: column !important;
                align-items: flex-start !important;
                gap: var(--spacing-sm) !important;
                min-height: auto !important;
                margin-bottom: var(--spacing-md) !important;
                overflow: visible !important;
            }
            
            .chart-title {
                font-size: 0.95rem !important;
                max-width: 100% !important;
            }
            
            .chart-title span {
                white-space: normal !important;
            }
            
            .chart-actions {
                width: 100% !important;
                flex-wrap: nowrap !important;
                overflow: visible !important;
                gap: var(--spacing-xs) !important;
            }
            
            .filter-selector {
                flex: 1 !important;
                min-width: 0 !important;
                font-size: 0.8rem !important;
                padding: var(--spacing-xs) var(--spacing-sm) !important;
            }
            
            .chart-control-btn {
                flex-shrink: 0 !important;
            }
            
            /* Melhorar grid de estatísticas em mobile */
            .stats-grid {
                grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)) !important;
                gap: var(--spacing-md) !important;
            }
            
            .stats-card {
                padding: var(--spacing-md) !important;
            }
            
            .stats-card-icon {
                width: 2.25rem !important;
                height: 2.25rem !important;
                font-size: 1.125rem !important;
                margin-bottom: var(--spacing-sm) !important;
            }
            
            .stats-card-value {
                font-size: 1.625rem !important;
                margin-bottom: 0.125rem !important;
            }
            
            .stats-card-label {
                font-size: 0.75rem !important;
                line-height: 1.3 !important;
            }
        }
        
        @media (max-width: 480px) {
            /* Otimizações para telas muito pequenas */
            .chart-container {
                height: 400px !important;
                padding: var(--spacing-sm) !important;
            }
            
            .chart-container canvas {
                max-height: 300px !important;
                height: 300px !important;
            }
            
            .chart-title {
                font-size: 0.85rem !important;
            }
            
            .chart-title i {
                font-size: 0.85rem !important;
            }
            
            /* Grid de uma coluna em telas muito pequenas */
            .stats-grid {
                grid-template-columns: 1fr !important;
                gap: var(--spacing-sm) !important;
            }
            
            .stats-card {
                padding: var(--spacing-sm) var(--spacing-md) !important;
            }
            
            .stats-card-icon {
                width: 1.875rem !important;
                height: 1.875rem !important;
                font-size: 0.95rem !important;
                margin-bottom: 0.375rem !important;
                border-radius: var(--radius-sm) !important;
            }
            
            .stats-card-value {
                font-size: 1.375rem !important;
                margin-bottom: 0 !important;
                line-height: 1.1 !important;
            }
            
            .stats-card-label {
                font-size: 0.7rem !important;
                line-height: 1.25 !important;
            }
            
            /* Garantir que os filtros sejam visíveis */
            .chart-actions {
                display: flex !important;
                flex-wrap: nowrap !important;
                justify-content: stretch !important;
                gap: var(--spacing-xs) !important;
            }
            
            .filter-selector {
                flex: 1 !important;
                font-size: 0.75rem !important;
                padding: var(--spacing-xs) !important;
                min-width: 0 !important;
            }
            
            .chart-control-btn {
                padding: var(--spacing-xs) !important;
                flex-shrink: 0 !important;
            }
            
            /* Ajustar header para evitar overflow */
            .chart-header {
                overflow: visible !important;
                padding-bottom: var(--spacing-sm) !important;
            }
        }
        
        /* Media query adicional para telas médias (tablets em landscape) */
        @media (max-width: 1200px) and (min-width: 769px) {
            .chart-container {
                height: 480px !important;
            }
            
            .chart-container canvas {
                max-height: 380px !important;
                height: 380px !important;
            }
        }
    </style>
</head>

<body>
    <!-- Admin View Status Bar -->
    <div id="adminStatusBar" class="admin-status-bar" style="display: none;">
        <div class="admin-status-content">
            <i class="fas fa-eye"></i>
            <span>Modo Visualização Administrador</span>
            <span id="adminViewCompany" class="admin-view-company"></span>
            <button class="admin-status-close" onclick="returnToAdmin()">
                <i class="fas fa-times"></i>
            </button>
        </div>
    </div>
    
    <!-- Overlay para fechar sidebar em mobile -->
    <div class="sidebar-overlay" data-sidebar-overlay></div>
    
    <!-- Sidebar -->
    <aside class="sidebar">
        <div class="sidebar-header">
            <div class="navbar-brand">
                <i class="fas fa-seedling"></i>
                <span>WR10</span>
            </div>
            <p class="subtitle" style="color: var(--text-gray); font-size: 0.875rem; margin-top: var(--spacing-sm);">
                Plano Básico
            </p>
        </div>
        
        <nav>
            <ul class="sidebar-nav">
                <li class="sidebar-nav-item">
                    <a href="dashboard.html" class="sidebar-nav-link active">
                        <i class="fas fa-chart-line"></i>
                        Dashboard
                    </a>
                </li>
                <li class="sidebar-nav-item">
                    <a href="dispositivos.html" class="sidebar-nav-link">
                        <i class="fas fa-microchip"></i>
                        Estações
                    </a>
                </li>
                <li class="sidebar-nav-item">
                    <a href="dados.html" class="sidebar-nav-link">
                        <i class="fas fa-database"></i>
                        Dados
                    </a>
                </li>
                <li class="sidebar-nav-item">
                    <a href="vento.html" class="sidebar-nav-link">
                        <i class="fas fa-wind"></i>
                        Vento
                    </a>
                </li>
                <li class="sidebar-nav-item">
                    <a href="#" class="sidebar-nav-link disabled">
                        <i class="fas fa-tint"></i>
                        Irrigação
                    </a>
                </li>
                <li class="sidebar-nav-item">
                    <a href="configuracoes.html" class="sidebar-nav-link">
                        <i class="fas fa-cog"></i>
                        Configurações
                    </a>
                </li>
            </ul>
        </nav>
        
        <div style="margin-top: auto; padding-top: var(--spacing-xl);">
            <div id="adminNavItem" class="sidebar-nav-item" style="display: none;">
                <a href="admin-dashboard.html" class="sidebar-nav-link" id="adminNavLink">
                    <i class="fas fa-user-shield"></i>
                    <span id="adminNavText">Painel Admin</span>
                </a>
            </div>
            <div class="sidebar-nav-item">
                <a href="#" class="sidebar-nav-link" id="logoutBtn">
                    <i class="fas fa-sign-out-alt"></i>
                    Sair
                </a>
            </div>
            <div style="padding: var(--spacing-md); text-align: center; font-size: 0.75rem; color: var(--text-gray);">
                <div style="margin-bottom: 4px;">
                    <i class="fas fa-user"></i>
                    <span id="userInfo">Carregando...</span>
                </div>
                <div id="companyInfo" style="font-size: 0.7rem; opacity: 0.8;">
                    <i class="fas fa-building"></i>
                    <span id="companyName">-</span>
                </div>
            </div>
        </div>
    </aside>

    <!-- Conteúdo Principal -->
    <main class="main-content">
        <div class="content-header">
            <div class="d-flex justify-content-between align-items-start">
                <div class="flex-grow-1">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <div>
                            <h1 class="mb-1">Dashboard</h1>
                            <p class="mb-0 text-muted">Visão geral do sistema de monitoramento</p>
                        </div>
                        <div class="ml-auto">
                            <button class="btn-hamburger" data-sidebar-toggle aria-label="Abrir/Fechar Menu">
                                <span class="hamburger-line"></span>
                                <span class="hamburger-line"></span>
                                <span class="hamburger-line"></span>
                            </button>
                        </div>
                    </div>
                    <div class="d-flex gap-2">
                        <button class="btn btn-secondary btn-sm" onclick="loadDashboardData()">
                            <i class="fas fa-sync-alt"></i>
                            Atualizar Dados
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="content-body">
            <!-- Status Cards -->
            <div class="stats-grid">
                <div class="stats-card" style="display: none;">
                    <div class="stats-card-icon info">
                        <i class="fas fa-tint"></i>
                    </div>
                    <div class="stats-card-value" id="avgHumidity">0%</div>
                    <div class="stats-card-label">Umidade Média do Solo</div>
                </div>
                
                <div class="stats-card">
                    <div class="stats-card-icon warning">
                        <i class="fas fa-cloud-rain"></i>
                    </div>
                    <div class="stats-card-value" id="totalRain">0mm</div>
                    <div class="stats-card-label">Precipitação no Período</div>
                </div>
                
                <div class="stats-card">
                    <div class="stats-card-icon success">
                        <i class="fas fa-wind"></i>
                    </div>
                    <div class="stats-card-value" id="avgTemp">0°C</div>
                    <div class="stats-card-label">Temperatura do Ar</div>
                </div>
                
                <div class="stats-card">
                    <div class="stats-card-icon info">
                        <i class="fas fa-cloud"></i>
                    </div>
                    <div class="stats-card-value" id="avgRelativeHumidity">0%</div>
                    <div class="stats-card-label">Umidade Relativa do Ar</div>
                </div>
                
                <div class="stats-card">
                    <div class="stats-card-icon primary">
                        <i class="fas fa-microchip"></i>
                    </div>
                    <div class="stats-card-value" id="deviceCount">0</div>
                    <div class="stats-card-label">Estações Online</div>
                </div>
                
                <!-- Card de Vento -->
                <a href="vento.html" class="stats-card wind-compass-card" style="text-decoration: none; color: inherit;">
                    <div class="wind-compass-container">
                        <div class="wind-compass">
                            <!-- Indicador de direção (Seta) - Aponta para Norte por padrão -->
                            <div class="wind-arrow" style="transform: translateX(-50%) rotate(0deg);"></div>
                            
                            <!-- Direções Cardinais -->
                            <span class="wind-direction north">N</span>
                            <span class="wind-direction south">S</span>
                            <span class="wind-direction east">E</span>
                            <span class="wind-direction west">W</span>
                            
                            <!-- Direções Intermediárias -->
                            <span class="wind-direction northeast">NE</span>
                            <span class="wind-direction northwest">NW</span>
                            <span class="wind-direction southeast">SE</span>
                            <span class="wind-direction southwest">SW</span>
                            
                            <!-- Marcadores de direção -->
                            <div class="wind-marker cardinal" style="top: 0; transform: translateX(-50%);"></div>
                            <div class="wind-marker cardinal" style="bottom: 0; transform: translateX(-50%);"></div>
                            <div class="wind-marker cardinal" style="right: 0; top: 50%; transform: translateY(-50%) rotate(90deg);"></div>
                            <div class="wind-marker cardinal" style="left: 0; top: 50%; transform: translateY(-50%) rotate(90deg);"></div>
                            
                            <!-- Centro com velocidade -->
                            <div class="wind-center">
                                <div class="wind-speed">0.0</div>
                                <div class="wind-unit">km/h</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="wind-label">Velocidade e Direção do Vento</div>
                </a>
                
                <!-- Card Registros Hoje - OCULTO -->
                <div class="stats-card" style="display: none;">
                    <div class="stats-card-icon success">
                        <i class="fas fa-database"></i>
                    </div>
                    <div class="stats-card-value" id="readingCount">0</div>
                    <div class="stats-card-label">Registros Hoje</div>
                </div>
            </div>
            
            <!-- Status do Dispositivo -->
            <div id="deviceStatusContainer" style="display: none;"></div>
            
            <!-- Gráficos -->
            <!-- Umidade do Solo (oculto para uso futuro) -->
            <div style="display: none;">
                <div class="chart-container" id="humidityChartContainer">
                        <div class="chart-header">
                            <h3 class="chart-title">
                                <i class="fas fa-chart-area"></i>
                                <span>Umidade do Solo</span>
                            </h3>
                            <div class="chart-actions">
                                <select class="filter-selector" id="humidityFilter" onchange="updateHumidityChart()">
                                    <option value="24h">Últimas 24h</option>
                                    <option value="7d">Últimos 7 dias</option>
                                    <option value="30d">Últimos 30 dias</option>
                                    <option value="all">Todos os dados</option>
                                </select>
                                <div style="position: relative;">
                                    <button class="chart-control-btn" id="humiditySettingsBtn" onclick="toggleChartSettings('humidity')">
                                        <i class="fas fa-cog"></i>
                                    </button>
                                    <div class="chart-settings-dropdown" id="humiditySettings">
                                        <div class="chart-settings-section">
                                            <label class="chart-settings-label">Tipo de Gráfico</label>
                                            <div class="chart-type-buttons">
                                                <button class="chart-type-btn active" data-type="line" onclick="changeChartType('humidity', 'line')">
                                                    <i class="fas fa-chart-line"></i>
                                                    <span>Linha</span>
                                                </button>
                                                <button class="chart-type-btn" data-type="bar" onclick="changeChartType('humidity', 'bar')">
                                                    <i class="fas fa-chart-bar"></i>
                                                    <span>Barra</span>
                                                </button>
                                                <button class="chart-type-btn" data-type="area" onclick="changeChartType('humidity', 'area')">
                                                    <i class="fas fa-chart-area"></i>
                                                    <span>Área</span>
                                                </button>
                                            </div>
                                        </div>
                                        <div class="chart-settings-section">
                                            <div class="chart-settings-toggle">
                                                <span>Mostrar Grid</span>
                                                <div class="toggle-switch active" onclick="toggleChartGrid('humidity')" id="humidityGridToggle"></div>
                                            </div>
                                            <div class="chart-settings-toggle">
                                                <span>Mostrar Pontos</span>
                                                <div class="toggle-switch active" onclick="toggleChartPoints('humidity')" id="humidityPointsToggle"></div>
                                            </div>
                                            <div class="chart-settings-toggle">
                                                <span>Preencher Área</span>
                                                <div class="toggle-switch active" onclick="toggleChartFill('humidity')" id="humidityFillToggle"></div>
                                            </div>
                                        </div>
                                        <div class="chart-settings-section">
                                            <label class="chart-settings-label">Limite de Registros</label>
                                            <div style="display: flex; align-items: center; gap: 8px;">
                                                <input 
                                                    type="number" 
                                                    id="humidityMaxRecords" 
                                                    min="10" 
                                                    max="10000" 
                                                    step="10" 
                                                    value="100" 
                                                    onchange="changeChartMaxRecords('humidity', this.value)"
                                                    style="flex: 1; padding: 6px 8px; border: 1px solid var(--border-gray); border-radius: var(--radius-sm); font-size: 0.875rem;"
                                                />
                                                <span style="font-size: 0.75rem; color: var(--text-gray); white-space: nowrap;">registros</span>
                                            </div>
                                            <div style="margin-top: 4px; font-size: 0.7rem; color: var(--text-gray);">
                                                Menos registros = gráfico mais rápido
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <canvas id="humidityChart"></canvas>
                    </div>
            </div>

            <!-- Row 1: Precipitação e Temperatura do Ar -->
            <div class="row">
                <div class="col-6">
                    <div class="chart-container" id="rainChartContainer">
                        <div class="chart-header">
                            <h3 class="chart-title">
                                <i class="fas fa-cloud-rain"></i>
                                <span>Precipitação</span>
                            </h3>
                            <div class="chart-actions">
                                <select class="filter-selector" id="rainFilter" onchange="updateRainChart()">
                                    <option value="24h">Últimas 24h</option>
                                    <option value="7d">Últimos 7 dias</option>
                                    <option value="30d">Últimos 30 dias</option>
                                    <option value="all">Todos os dados</option>
                                </select>
                                <div style="position: relative;">
                                    <button class="chart-control-btn" id="rainSettingsBtn" onclick="toggleChartSettings('rain')">
                                        <i class="fas fa-cog"></i>
                                    </button>
                                    <div class="chart-settings-dropdown" id="rainSettings">
                                        <div class="chart-settings-section">
                                            <label class="chart-settings-label">Tipo de Gráfico</label>
                                            <div class="chart-type-buttons">
                                                <button class="chart-type-btn active" data-type="line" onclick="changeChartType('rain', 'line')">
                                                    <i class="fas fa-chart-line"></i>
                                                    <span>Linha</span>
                                                </button>
                                                <button class="chart-type-btn" data-type="bar" onclick="changeChartType('rain', 'bar')">
                                                    <i class="fas fa-chart-bar"></i>
                                                    <span>Barra</span>
                                                </button>
                                                <button class="chart-type-btn" data-type="area" onclick="changeChartType('rain', 'area')">
                                                    <i class="fas fa-chart-area"></i>
                                                    <span>Área</span>
                                                </button>
                                            </div>
                                        </div>
                                        <div class="chart-settings-section">
                                            <div class="chart-settings-toggle">
                                                <span>Mostrar Grid</span>
                                                <div class="toggle-switch active" onclick="toggleChartGrid('rain')" id="rainGridToggle"></div>
                                            </div>
                                            <div class="chart-settings-toggle">
                                                <span>Mostrar Pontos</span>
                                                <div class="toggle-switch active" onclick="toggleChartPoints('rain')" id="rainPointsToggle"></div>
                                            </div>
                                            <div class="chart-settings-toggle">
                                                <span>Preencher Área</span>
                                                <div class="toggle-switch active" onclick="toggleChartFill('rain')" id="rainFillToggle"></div>
                                            </div>
                                        </div>
                                        <div class="chart-settings-section">
                                            <label class="chart-settings-label">Limite de Registros</label>
                                            <div style="display: flex; align-items: center; gap: 8px;">
                                                <input 
                                                    type="number" 
                                                    id="rainMaxRecords" 
                                                    min="10" 
                                                    max="10000" 
                                                    step="10" 
                                                    value="100" 
                                                    onchange="changeChartMaxRecords('rain', this.value)"
                                                    style="flex: 1; padding: 6px 8px; border: 1px solid var(--border-gray); border-radius: var(--radius-sm); font-size: 0.875rem;"
                                                />
                                                <span style="font-size: 0.75rem; color: var(--text-gray); white-space: nowrap;">registros</span>
                                            </div>
                                            <div style="margin-top: 4px; font-size: 0.7rem; color: var(--text-gray);">
                                                Menos registros = gráfico mais rápido
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <canvas id="rainChart"></canvas>
                    </div>
                </div>
                
                <div class="col-6">
                    <div class="chart-container" id="airTempChartContainer">
                        <div class="chart-header">
                            <h3 class="chart-title">
                                <i class="fas fa-thermometer-half"></i>
                                <span>Temperatura do Ar</span>
                            </h3>
                            <div class="chart-actions">
                                <select class="filter-selector" id="airTempFilter" onchange="updateAirTempChart()">
                                    <option value="24h">Últimas 24h</option>
                                    <option value="7d">Últimos 7 dias</option>
                                    <option value="30d">Últimos 30 dias</option>
                                    <option value="all">Todos os dados</option>
                                </select>
                                <div style="position: relative;">
                                    <button class="chart-control-btn" id="airTempSettingsBtn" onclick="toggleChartSettings('airTemp')">
                                        <i class="fas fa-cog"></i>
                                    </button>
                                    <div class="chart-settings-dropdown" id="airTempSettings">
                                        <div class="chart-settings-section">
                                            <label class="chart-settings-label">Tipo de Gráfico</label>
                                            <div class="chart-type-buttons">
                                                <button class="chart-type-btn active" data-type="line" onclick="changeChartType('airTemp', 'line')">
                                                    <i class="fas fa-chart-line"></i>
                                                    <span>Linha</span>
                                                </button>
                                                <button class="chart-type-btn" data-type="bar" onclick="changeChartType('airTemp', 'bar')">
                                                    <i class="fas fa-chart-bar"></i>
                                                    <span>Barra</span>
                                                </button>
                                                <button class="chart-type-btn" data-type="area" onclick="changeChartType('airTemp', 'area')">
                                                    <i class="fas fa-chart-area"></i>
                                                    <span>Área</span>
                                                </button>
                                            </div>
                                        </div>
                                        <div class="chart-settings-section">
                                            <div class="chart-settings-toggle">
                                                <span>Mostrar Grid</span>
                                                <div class="toggle-switch active" onclick="toggleChartGrid('airTemp')" id="airTempGridToggle"></div>
                                            </div>
                                            <div class="chart-settings-toggle">
                                                <span>Mostrar Pontos</span>
                                                <div class="toggle-switch active" onclick="toggleChartPoints('airTemp')" id="airTempPointsToggle"></div>
                                            </div>
                                            <div class="chart-settings-toggle">
                                                <span>Preencher Área</span>
                                                <div class="toggle-switch active" onclick="toggleChartFill('airTemp')" id="airTempFillToggle"></div>
                                            </div>
                                        </div>
                                        <div class="chart-settings-section">
                                            <label class="chart-settings-label">Limite de Registros</label>
                                            <div style="display: flex; align-items: center; gap: 8px;">
                                                <input 
                                                    type="number" 
                                                    id="airTempMaxRecords" 
                                                    min="10" 
                                                    max="10000" 
                                                    step="10" 
                                                    value="100" 
                                                    onchange="changeChartMaxRecords('airTemp', this.value)"
                                                    style="flex: 1; padding: 6px 8px; border: 1px solid var(--border-gray); border-radius: var(--radius-sm); font-size: 0.875rem;"
                                                />
                                                <span style="font-size: 0.75rem; color: var(--text-gray); white-space: nowrap;">registros</span>
                                            </div>
                                            <div style="margin-top: 4px; font-size: 0.7rem; color: var(--text-gray);">
                                                Menos registros = gráfico mais rápido
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <canvas id="airTempChart"></canvas>
                    </div>
                </div>
            </div>

            <div class="row">
                <div class="col-6">
                    <div class="chart-container" id="airHumidityChartContainer">
                        <div class="chart-header">
                            <h3 class="chart-title">
                                <i class="fas fa-cloud"></i>
                                <span>Umidade do Ar</span>
                            </h3>
                            <div class="chart-actions">
                                <select class="filter-selector" id="airHumidityFilter" onchange="updateAirHumidityChart()">
                                    <option value="24h">Últimas 24h</option>
                                    <option value="7d">Últimos 7 dias</option>
                                    <option value="30d">Últimos 30 dias</option>
                                    <option value="all">Todos os dados</option>
                                </select>
                                <div style="position: relative;">
                                    <button class="chart-control-btn" id="airHumiditySettingsBtn" onclick="toggleChartSettings('airHumidity')">
                                        <i class="fas fa-cog"></i>
                                    </button>
                                    <div class="chart-settings-dropdown" id="airHumiditySettings">
                                        <div class="chart-settings-section">
                                            <label class="chart-settings-label">Tipo de Gráfico</label>
                                            <div class="chart-type-buttons">
                                                <button class="chart-type-btn active" data-type="line" onclick="changeChartType('airHumidity', 'line')">
                                                    <i class="fas fa-chart-line"></i>
                                                    <span>Linha</span>
                                                </button>
                                                <button class="chart-type-btn" data-type="bar" onclick="changeChartType('airHumidity', 'bar')">
                                                    <i class="fas fa-chart-bar"></i>
                                                    <span>Barra</span>
                                                </button>
                                                <button class="chart-type-btn" data-type="area" onclick="changeChartType('airHumidity', 'area')">
                                                    <i class="fas fa-chart-area"></i>
                                                    <span>Área</span>
                                                </button>
                                            </div>
                                        </div>
                                        <div class="chart-settings-section">
                                            <div class="chart-settings-toggle">
                                                <span>Mostrar Grid</span>
                                                <div class="toggle-switch active" onclick="toggleChartGrid('airHumidity')" id="airHumidityGridToggle"></div>
                                            </div>
                                            <div class="chart-settings-toggle">
                                                <span>Mostrar Pontos</span>
                                                <div class="toggle-switch active" onclick="toggleChartPoints('airHumidity')" id="airHumidityPointsToggle"></div>
                                            </div>
                                            <div class="chart-settings-toggle">
                                                <span>Preencher Área</span>
                                                <div class="toggle-switch active" onclick="toggleChartFill('airHumidity')" id="airHumidityFillToggle"></div>
                                            </div>
                                        </div>
                                        <div class="chart-settings-section">
                                            <label class="chart-settings-label">Limite de Registros</label>
                                            <div style="display: flex; align-items: center; gap: 8px;">
                                                <input 
                                                    type="number" 
                                                    id="airHumidityMaxRecords" 
                                                    min="10" 
                                                    max="10000" 
                                                    step="10" 
                                                    value="100" 
                                                    onchange="changeChartMaxRecords('airHumidity', this.value)"
                                                    style="flex: 1; padding: 6px 8px; border: 1px solid var(--border-gray); border-radius: var(--radius-sm); font-size: 0.875rem;"
                                                />
                                                <span style="font-size: 0.75rem; color: var(--text-gray); white-space: nowrap;">registros</span>
                                            </div>
                                            <div style="margin-top: 4px; font-size: 0.7rem; color: var(--text-gray);">
                                                Menos registros = gráfico mais rápido
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <canvas id="airHumidityChart"></canvas>
                    </div>
                </div>
                
                <div class="col-6">
                    <div class="chart-container" id="windChartContainer">
                        <div class="chart-header">
                            <h3 class="chart-title">
                                <i class="fas fa-wind"></i>
                                <span>Vento</span>
                            </h3>
                            <div class="chart-actions">
                                <select class="filter-selector" id="windFilter" onchange="updateWindChart()">
                                    <option value="24h">Últimas 24h</option>
                                    <option value="7d">Últimos 7 dias</option>
                                    <option value="30d">Últimos 30 dias</option>
                                    <option value="all">Todos os dados</option>
                                </select>
                                <div style="position: relative;">
                                    <button class="chart-control-btn" id="windSettingsBtn" onclick="toggleChartSettings('wind')">
                                        <i class="fas fa-cog"></i>
                                    </button>
                                    <div class="chart-settings-dropdown" id="windSettings">
                                        <div class="chart-settings-section">
                                            <label class="chart-settings-label">Tipo de Gráfico</label>
                                            <div class="chart-type-buttons">
                                                <button class="chart-type-btn active" data-type="line" onclick="changeChartType('wind', 'line')">
                                                    <i class="fas fa-chart-line"></i>
                                                    <span>Linha</span>
                                                </button>
                                                <button class="chart-type-btn" data-type="bar" onclick="changeChartType('wind', 'bar')">
                                                    <i class="fas fa-chart-bar"></i>
                                                    <span>Barra</span>
                                                </button>
                                                <button class="chart-type-btn" data-type="area" onclick="changeChartType('wind', 'area')">
                                                    <i class="fas fa-chart-area"></i>
                                                    <span>Área</span>
                                                </button>
                                            </div>
                                        </div>
                                        <div class="chart-settings-section">
                                            <div class="chart-settings-toggle">
                                                <span>Mostrar Grid</span>
                                                <div class="toggle-switch active" onclick="toggleChartGrid('wind')" id="windGridToggle"></div>
                                            </div>
                                            <div class="chart-settings-toggle">
                                                <span>Mostrar Pontos</span>
                                                <div class="toggle-switch active" onclick="toggleChartPoints('wind')" id="windPointsToggle"></div>
                                            </div>
                                            <div class="chart-settings-toggle">
                                                <span>Preencher Área</span>
                                                <div class="toggle-switch active" onclick="toggleChartFill('wind')" id="windFillToggle"></div>
                                            </div>
                                        </div>
                                        <div class="chart-settings-section">
                                            <label class="chart-settings-label">Limite de Registros</label>
                                            <div style="display: flex; align-items: center; gap: 8px;">
                                                <input 
                                                    type="number" 
                                                    id="windMaxRecords" 
                                                    min="10" 
                                                    max="10000" 
                                                    step="10" 
                                                    value="100" 
                                                    onchange="changeChartMaxRecords('wind', this.value)"
                                                    style="flex: 1; padding: 6px 8px; border: 1px solid var(--border-gray); border-radius: var(--radius-sm); font-size: 0.875rem;"
                                                />
                                                <span style="font-size: 0.75rem; color: var(--text-gray); white-space: nowrap;">registros</span>
                                            </div>
                                            <div style="margin-top: 4px; font-size: 0.7rem; color: var(--text-gray);">
                                                Menos registros = gráfico mais rápido
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <canvas id="windChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Gráficos de Média Diária - DESATIVADO TEMPORARIAMENTE -->
            <div class="row" style="display: none !important;">
                <div class="col-6">
                    <div class="chart-container">
                        <div class="chart-header">
                            <h3 class="chart-title">
                                <i class="fas fa-calendar-day" style="color: #3182ce;"></i>
                                Média Diária de Umidade
                            </h3>
                            <div class="chart-actions">
                                <select class="filter-selector" id="humidityAvgFilter" onchange="updateHumidityAvgChart()">
                                    <option value="7d">Últimos 7 dias</option>
                                    <option value="30d" selected>Últimos 30 dias</option>
                                    <option value="all">Todos</option>
                                </select>
                                <button class="chart-control-btn" onclick="toggleChartSettings('humidityAvg')">
                                    <i class="fas fa-cog"></i>
                                    <span>Personalizar</span>
                                </button>
                                <div id="humidityAvgSettings" class="chart-settings-dropdown">
                                    <div class="chart-settings-section">
                                        <label class="chart-settings-label">Tipo de Gráfico</label>
                                        <div class="chart-type-buttons">
                                            <button class="chart-type-btn" onclick="changeChartType('humidityAvg', 'line')">
                                                <i class="fas fa-chart-line"></i>
                                                <span>Linha</span>
                                            </button>
                                            <button class="chart-type-btn" onclick="changeChartType('humidityAvg', 'area')">
                                                <i class="fas fa-chart-area"></i>
                                                <span>Área</span>
                                            </button>
                                            <button class="chart-type-btn active" onclick="changeChartType('humidityAvg', 'bar')">
                                                <i class="fas fa-chart-bar"></i>
                                                <span>Barras</span>
                                            </button>
                                        </div>
                                    </div>
                                    <div class="chart-settings-section">
                                        <div class="chart-settings-toggle">
                                            <span>Mostrar Grade</span>
                                            <div class="toggle-switch active" id="humidityAvgGridToggle" onclick="toggleChartGrid('humidityAvg')"></div>
                                        </div>
                                        <div class="chart-settings-toggle">
                                            <span>Mostrar Pontos</span>
                                            <div class="toggle-switch" id="humidityAvgPointsToggle" onclick="toggleChartPoints('humidityAvg')"></div>
                                        </div>
                                        <div class="chart-settings-toggle">
                                            <span>Preenchimento</span>
                                            <div class="toggle-switch" id="humidityAvgFillToggle" onclick="toggleChartFill('humidityAvg')"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <canvas id="humidityAvgChart"></canvas>
                    </div>
                </div>
                
                <div class="col-6">
                    <div class="chart-container">
                        <div class="chart-header">
                            <h3 class="chart-title">
                                <i class="fas fa-calendar-day" style="color: #7fb069;"></i>
                                Total Diário de Chuva
                            </h3>
                            <div class="chart-actions">
                                <select class="filter-selector" id="rainAvgFilter" onchange="updateRainAvgChart()">
                                    <option value="7d">Últimos 7 dias</option>
                                    <option value="30d" selected>Últimos 30 dias</option>
                                    <option value="all">Todos</option>
                                </select>
                                <button class="chart-control-btn" onclick="toggleChartSettings('rainAvg')">
                                    <i class="fas fa-cog"></i>
                                    <span>Personalizar</span>
                                </button>
                                <div id="rainAvgSettings" class="chart-settings-dropdown">
                                    <div class="chart-settings-section">
                                        <label class="chart-settings-label">Tipo de Gráfico</label>
                                        <div class="chart-type-buttons">
                                            <button class="chart-type-btn" onclick="changeChartType('rainAvg', 'line')">
                                                <i class="fas fa-chart-line"></i>
                                                <span>Linha</span>
                                            </button>
                                            <button class="chart-type-btn" onclick="changeChartType('rainAvg', 'area')">
                                                <i class="fas fa-chart-area"></i>
                                                <span>Área</span>
                                            </button>
                                            <button class="chart-type-btn active" onclick="changeChartType('rainAvg', 'bar')">
                                                <i class="fas fa-chart-bar"></i>
                                                <span>Barras</span>
                                            </button>
                                        </div>
                                    </div>
                                    <div class="chart-settings-section">
                                        <div class="chart-settings-toggle">
                                            <span>Mostrar Grade</span>
                                            <div class="toggle-switch active" id="rainAvgGridToggle" onclick="toggleChartGrid('rainAvg')"></div>
                                        </div>
                                        <div class="chart-settings-toggle">
                                            <span>Mostrar Pontos</span>
                                            <div class="toggle-switch" id="rainAvgPointsToggle" onclick="toggleChartPoints('rainAvg')"></div>
                                        </div>
                                        <div class="chart-settings-toggle">
                                            <span>Preenchimento</span>
                                            <div class="toggle-switch" id="rainAvgFillToggle" onclick="toggleChartFill('rainAvg')"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <canvas id="rainAvgChart"></canvas>
                    </div>
                </div>
            </div>
            
            <!-- Leituras Recentes - OCULTO -->
            <div class="latest-readings" style="display: none;">
                <div class="readings-header">
                    <h3 class="mb-0">
                        <i class="fas fa-clock"></i>
                        Últimas Leituras
                    </h3>
                    <a href="dados.html" class="btn btn-sm btn-secondary">
                        Ver todas <i class="fas fa-arrow-right"></i>
                    </a>
                </div>
                <div class="readings-list" id="latestReadings">
                    <!-- Será preenchido via JavaScript -->
                </div>
            </div>
        </div>
    </main>

    <!-- Scripts -->
    <script src="../assets/js/app.js"></script>
    <script>
        // Variáveis globais dos gráficos
        let humidityChart = null;
        let rainChart = null;
        let airTempChart = null;
        let airHumidityChart = null;
        let windChart = null;
        let humidityAvgChart = null;
        let rainAvgChart = null;
        
        // Função de inicialização e verificações
        function initPage() {
            // Verificar se AuthManager está disponível
            if (typeof AuthManager === 'undefined') {
                console.warn('AuthManager não está disponível ainda');
                return false;
            }

            try {
                // Verificar autenticação e permissões
                if (!AuthManager.redirectIfNotAuthenticated()) {
                    throw new Error('Não autenticado');
                }

                // Verificar se é usuário comum - admins devem ir para admin-dashboard
                if (AuthManager.isAdmin()) {
                    const urlParams = new URLSearchParams(window.location.search);
                    const isAdminView = urlParams.get('admin_view') === 'true';
                    
                    // Se é admin mas não está em modo de visualização admin, redirecionar
                    if (!isAdminView && !urlParams.get('company_id')) {
                        window.location.href = 'admin-dashboard.html';
                        return false;
                    }
                    
                    // Se está em modo admin_view, criar contexto especial
                    if (isAdminView) {
                        window.adminViewMode = true;
                        window.adminViewCompanyId = urlParams.get('company_id');
                        console.log('Modo visualização admin ativado para empresa:', window.adminViewCompanyId);
                    }
                }
                return true;
            } catch (error) {
                console.error('Erro na inicialização:', error);
                return false;
            }
        }

        // Função helper para notificações
        function showNotification(type, title, message) {
            if (window.NotificationManager && typeof window.NotificationManager[type] === 'function') {
                window.NotificationManager[type](title, message);
            } else {
                // Fallback para alert se NotificationManager não estiver disponível
                alert(`${title}: ${message}`);
            }
        }
        
        // Função para interceptar cliques em links desabilitados
        function handleDisabledLinks() {
            document.querySelectorAll('.sidebar-nav-link.disabled').forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    showNotification('info', 'Funcionalidade em desenvolvimento', 'Esta funcionalidade estará disponível em breve.');
                });
            });
        }

        // Obter company_id para administradores via query parameter
        const urlParams = new URLSearchParams(window.location.search);
        const adminCompanyId = urlParams.get('company_id');
        const isAdminView = urlParams.get('admin') === 'true';

        // Dados dos sensores organizados por dispositivo
        let sensorsDataByDevice = {};
        let latestReadings = [];
        
        // Sistema para evitar requisições duplicadas simultâneas (sem cache)
        let pendingRequests = {
            '24h': null,
            '7d': null,
            '30d': null,
            'all': null
        };
        
        // Inicialização da página
        document.addEventListener('DOMContentLoaded', async function() {
            // Setup do menu mobile primeiro (não depende de APIs externas)
            setupMobileMenu();
            
            // Aguardar um pouco para garantir que app.js carregou
            setTimeout(async () => {
                try {
                    // Executar verificações de autenticação
                    const authSuccess = initPage();
                    
                    if (authSuccess) {
                        await initializeDashboard();
                        setupEventListeners();
                        handleDisabledLinks();
                    } else {
                        // Se autenticação falhou, ainda assim configurar eventos básicos
                        setupEventListeners();
                        handleDisabledLinks();
                    }
                } catch (error) {
                    console.error('Erro na inicialização:', error);
                    // Garantir que pelo menos o menu mobile funcione
                    setupEventListeners();
                }
            }, 100);
        });
        
        async function initializeDashboard() {
            try {
                LoadingManager.showGlobalLoading('Carregando dashboard...');
                
                // Carregar dados do usuário
                const user = AuthManager.getUserFromToken();
                if (user) {
                    const displayName = user.fullName || user.username || 'Usuário';
                    document.getElementById('userInfo').textContent = displayName;
                    
                    // Mostrar informações baseadas no tipo de usuário
                    if (user.userType === 'admin') {
                        document.getElementById('adminNavItem').style.display = 'block';
                        const viewCompanyId = window.adminViewCompanyId || adminCompanyId;
                        
                        // Ajustar comportamento do link admin baseado no modo
                        if (window.adminViewMode) {
                            document.getElementById('adminNavText').textContent = 'Voltar ao Admin';
                            document.getElementById('adminNavLink').title = 'Voltar ao painel administrativo';
                        }
                        
                        if (viewCompanyId) {
                            // Admin visualizando empresa específica
                            if (window.adminViewMode) {
                                document.getElementById('userInfo').textContent += ' (Visualizando como Admin)';
                            } else {
                                document.getElementById('userInfo').textContent += ' (Admin)';
                            }
                            await loadCompanyName(viewCompanyId);
                        }
                    } else if (user.userType === 'user' && user.company_id) {
                        // Usuário comum - carregar nome da empresa
                        await loadCompanyName(user.company_id);
                    }
                }
                
                // Inicializar gráficos primeiro
                initializeCharts();
                
                // Carregar dados do dashboard
                await loadDashboardData();
                
            } catch (error) {
                console.error('Erro ao inicializar dashboard:', error);
                showNotification('error', 'Erro', 'Falha ao carregar dados do dashboard');
            } finally {
                LoadingManager.hideGlobalLoading();
            }
        }

        async function loadCompanyName(companyId) {
            try {
                // Para usuários comuns, a empresa pode vir da API de configurações
                // Para admins, carregamos da API administrativa
                const user = AuthManager.getUserFromToken();
                if (user.userType === 'admin') {
                    const companies = await ApiClient.getCompanies();
                    const company = companies.companies?.find(c => c._id === companyId);
                    if (company) {
                        document.getElementById('companyName').textContent = company.nome;
                    }
                } else {
                    // Para usuários comuns, podemos tentar obter da configuração
                    document.getElementById('companyName').textContent = 'Minha Empresa';
                }
            } catch (error) {
                console.error('Erro ao carregar nome da empresa:', error);
                document.getElementById('companyName').textContent = '-';
            }
        }
        
        async function loadDashboardData() {
            try {
                // Determinar company_id para carregar dados
                const companyId = window.adminViewCompanyId || adminCompanyId || AuthManager.getCompanyId();
                
                // Sistema otimizado: buscar dados compartilhados uma única vez
                // Os gráficos usarão esses dados em vez de fazer requisições individuais
                await updateCharts();
                
            } catch (error) {
                console.error('Erro ao carregar dados:', error);
                // Mostrar mensagem de erro ao usuário
                alert('Erro ao carregar dados do servidor. Por favor, tente novamente.');
            }
        }
        
        // Função para buscar dados sem cache (sempre dados frescos)
        // Evita apenas requisições duplicadas simultâneas
        async function fetchSharedHistoryData(period = '24h') {
            const companyId = window.adminViewCompanyId || adminCompanyId || AuthManager.getCompanyId();
            
            // Se já há uma requisição em andamento para este período, aguardar ela
            if (pendingRequests[period]) {
                console.log(`⏳ Aguardando requisição em andamento (${period})...`);
                return await pendingRequests[period];
            }
            
            // Criar nova requisição
            const requestPromise = (async () => {
                try {
                    console.log(`🌐 Buscando dados em tempo real da API (período: ${period})`);
                    
                    const periodParam = period === 'all' ? null : period;
                    const response = await ApiClient.getSensorsHistory(companyId, periodParam);
                    const historyData = response?.dados || response || [];
                    
                    console.log(`✓ Dados carregados (${historyData.length} registros)`);
                    
                    return historyData;
                    
                } catch (error) {
                    console.error('Erro ao buscar dados:', error);
                    throw error;
                } finally {
                    // Limpar requisição pendente
                    pendingRequests[period] = null;
                }
            })();
            
            // Armazenar promise pendente
            pendingRequests[period] = requestPromise;
            
            return await requestPromise;
        }
        
        function processMultiSensorData(rawData) {
            // Limpar dados anteriores
            sensorsDataByDevice = {};
            
            // Agrupar dados por device_key
            rawData.forEach(reading => {
                const deviceKey = getReadingDeviceKey(reading);
                if (!deviceKey) {
                    return;
                }
                
                if (!sensorsDataByDevice[deviceKey]) {
                    // Usar o nome do sensor da API se disponível, senão gerar nome
                    const sensorName = reading.sensor_id?.nome || null;
                    const deviceName = sensorName ? 
                        { name: sensorName, location: `Dispositivo ${String(deviceKey).substring(0, 8)}` } : 
                        generateDeviceName(deviceKey);
                    
                    sensorsDataByDevice[deviceKey] = {
                        name: deviceName.name,
                        location: deviceName.location,
                        sensor_id: reading.sensor_id?._id || null,
                        isOnline: true, // Será calculado baseado na última leitura
                        readings: [],
                        // Informações de agrupamento
                        agrupamento_tipo: reading.agrupamento?.tipo || 'individual',
                        total_leituras: 0
                    };
                }
                
                // Adicionar leitura ao dispositivo
                sensorsDataByDevice[deviceKey].readings.push({
                    timestamp: reading.timestamp,
                    umidade_solo: reading.umidade_solo,
                    quantidade_chuva: reading.quantidade_chuva,
                    _id: reading._id,
                    // Incluir informações de agrupamento
                    agrupamento: reading.agrupamento || null,
                    data_local: reading.agrupamento?.data_local || null
                });
                
                // Acumular total de leituras agrupadas
                if (reading.agrupamento?.leituras_agrupadas) {
                    sensorsDataByDevice[deviceKey].total_leituras += reading.agrupamento.leituras_agrupadas;
                }
            });
            
            // Ordenar leituras por timestamp e calcular status online
            Object.keys(sensorsDataByDevice).forEach(deviceKey => {
                const device = sensorsDataByDevice[deviceKey];
                
                // Ordenar leituras (mais antigas primeiro)
                device.readings.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                
                // Calcular se está online (última leitura há menos de 30 minutos)
                if (device.readings.length > 0) {
                    const lastReading = device.readings[device.readings.length - 1];
                    const timeDiff = Date.now() - new Date(lastReading.timestamp).getTime();
                    device.isOnline = timeDiff < 30 * 60 * 1000; // 30 minutos
                }
            });
        }
        
        function getReadingDeviceKey(reading) {
            if (!reading) {
                return null;
            }
            if (reading.device_key) {
                return reading.device_key;
            }
            if (reading.sensor_id && typeof reading.sensor_id === 'string') {
                return reading.sensor_id;
            }
            if (reading.sensor_id && reading.sensor_id._id) {
                return reading.sensor_id._id;
            }
            if (reading._id && reading._id.sensor_id) {
                return reading._id.sensor_id;
            }
            return null;
        }

        function generateDeviceName(deviceKey) {
            if (!deviceKey) {
                return { name: 'Sensor desconhecido', location: 'Area desconhecida' };
            }
            const keyString = String(deviceKey);
            // Extrair parte única do device_key para criar nomes mais amigáveis
            const shortKey = keyString.split('-')[1]?.substring(0, 8) || keyString.substring(0, 8);
            
            // Mapear para nomes mais descritivos baseados no hash
            const nameMap = {
                '629e6a68': { name: 'Sensor Principal', location: 'Estufa A - Setor 1' },
                'a54d6cad': { name: 'Sensor Secundário', location: 'Campo Externo B' }
            };
            
            return nameMap[shortKey] || {
                name: `Sensor ${shortKey.toUpperCase()}`,
                location: `Área ${shortKey.substring(0, 3).toUpperCase()}`
            };
        }
        
        function updateMultiSensorStatistics() {
            // Contar dispositivos online/offline
            const devices = Object.values(sensorsDataByDevice);
            const onlineDevices = devices.filter(d => d.isOnline).length;
            const totalDevices = devices.length;
            
            // Calcular umidade média de todos os sensores (última leitura de cada)
            let totalHumidity = 0;
            let readingCount = 0;
            
            devices.forEach(sensor => {
                const latestReading = sensor.readings[sensor.readings.length - 1];
                if (latestReading) {
                    totalHumidity += latestReading.umidade_solo;
                    readingCount++;
                }
            });
            
            const avgHumidity = readingCount > 0 ? totalHumidity / readingCount : 0;
            
            // Calcular total de leituras agrupadas (dados originais)
            let totalLeiturasAgrupadas = 0;
            devices.forEach(sensor => {
                if (sensor.total_leituras) {
                    totalLeiturasAgrupadas += sensor.total_leituras;
                }
            });
            
            // Atualizar UI (NÃO atualizar precipitação aqui - será atualizado em updateRainChart)
            document.getElementById('deviceCount').textContent = `${onlineDevices}/${totalDevices}`;
            document.getElementById('avgHumidity').textContent = avgHumidity.toFixed(1) + '%';
            
            // Exibir total de leituras agrupadas se houver
            if (totalLeiturasAgrupadas > 0) {
                document.getElementById('readingCount').textContent = totalLeiturasAgrupadas.toLocaleString('pt-BR');
                document.getElementById('readingCount').title = `${totalLeiturasAgrupadas.toLocaleString('pt-BR')} leituras agrupadas`;
            } else {
                document.getElementById('readingCount').textContent = readingCount;
                document.getElementById('readingCount').title = 'Leituras atuais';
            }
            
            // Atualizar card de vento
            updateWindCard();
            
            // Atualizar cards de temperatura e umidade relativa
            updateAirTemperatureAndHumidityCard();
        }
        
        // Função para atualizar card de temperatura do ar e umidade relativa
        async function updateAirTemperatureAndHumidityCard() {
            try {
                // Usar cache compartilhado em vez de nova requisição
                const historyData = await fetchSharedHistoryData('24h');
                const data = { dados: historyData };
                
                if (data && data.dados && data.dados.length > 0) {
                    // Calcular média de temperatura do ar
                    let totalTemp = 0;
                    let tempCount = 0;
                    let totalRelativeHumidity = 0;
                    let humidityCount = 0;
                    
                    data.dados.forEach(item => {
                        // Aceitar tanto temperatura_ar quanto temperatura
                        const temp = item.temperatura_ar !== null && item.temperatura_ar !== undefined 
                            ? item.temperatura_ar 
                            : item.temperatura;
                        
                        if (temp !== null && temp !== undefined) {
                            totalTemp += temp;
                            tempCount++;
                        }
                        
                        // Aceitar tanto umidade_relativa quanto umidade_ar
                        const humidity = item.umidade_relativa !== null && item.umidade_relativa !== undefined
                            ? item.umidade_relativa
                            : item.umidade_ar;
                        
                        if (humidity !== null && humidity !== undefined) {
                            totalRelativeHumidity += humidity;
                            humidityCount++;
                        }
                    });
                    
                    const avgTemp = tempCount > 0 ? (totalTemp / tempCount).toFixed(1) : '0';
                    const avgRelHumidity = humidityCount > 0 ? (totalRelativeHumidity / humidityCount).toFixed(1) : '0';
                    
                    // Atualizar UI
                    const tempElement = document.getElementById('avgTemp');
                    if (tempElement) {
                        tempElement.textContent = avgTemp + '°C';
                    }
                    
                    const humidityElement = document.getElementById('avgRelativeHumidity');
                    if (humidityElement) {
                        humidityElement.textContent = avgRelHumidity + '%';
                    }
                }
            } catch (error) {
                console.error('Erro ao atualizar dados de temperatura e umidade relativa:', error);
                // Manter valores padrão em caso de erro
            }
        }
        
        // Função para atualizar card de vento no dashboard
        async function updateWindCard() {
            try {
                // Usar cache compartilhado em vez de nova requisição
                const historyData = await fetchSharedHistoryData('24h');
                const data = { dados: historyData };
                
                if (data && data.dados && data.dados.length > 0) {
                    // Filtrar apenas dados com vento válido
                    const dadosComVento = data.dados.filter(item => 
                        item.velocidade_vento !== null && item.velocidade_vento !== undefined
                    );
                    
                    if (dadosComVento.length > 0) {
                        // Pegar leitura MAIS RECENTE por timestamp
                        const latestWithWind = dadosComVento.reduce((newest, current) => {
                            const newestTime = new Date(newest.timestamp).getTime();
                            const currentTime = new Date(current.timestamp).getTime();
                            return currentTime > newestTime ? current : newest;
                        });
                        
                        const velocidade = latestWithWind.velocidade_vento || 0;
                        const direcao = latestWithWind.direcao_vento_cardinal || 'N';
                        const rotacao = WindUtils.getWindRotation(direcao);
                        
                        // Atualizar velocidade
                        const speedElement = document.querySelector('.wind-speed');
                        if (speedElement) {
                            speedElement.textContent = velocidade.toFixed(1);
                        }
                        
                        // Atualizar seta de direção
                        const arrowElement = document.querySelector('.wind-arrow');
                        if (arrowElement) {
                            arrowElement.style.transform = `translateX(-50%) rotate(${rotacao}deg)`;
                        }
                        
                        // Remover badge "Em Breve"
                        const badge = document.querySelector('.coming-soon-badge');
                        if (badge) {
                            badge.style.display = 'none';
                        }
                    }
                }
            } catch (error) {
                console.error('Erro ao atualizar card de vento:', error);
                // Manter valores padrão em caso de erro
            }
        }
        
        function updateMultiDeviceStatus() {
            const container = document.getElementById('deviceStatusContainer');
            
            if (Object.keys(sensorsDataByDevice).length === 0) {
                container.innerHTML = `
                    <div class="device-status">
                        <div class="status-dot offline"></div>
                        <div>
                            <strong>Nenhum dispositivo cadastrado</strong>
                            <p style="margin: 0; font-size: 0.875rem; color: var(--text-gray);">
                                Configure dispositivos para começar a receber dados
                            </p>
                        </div>
                    </div>
                `;
                return;
            }
            
            let html = '<div style="margin-bottom: var(--spacing-lg);"><h3 style="margin-bottom: var(--spacing-md); font-size: 1.125rem; color: var(--dark-gray);">Status dos Dispositivos</h3>';
            
            Object.entries(sensorsDataByDevice).forEach(([deviceKey, sensor]) => {
                const lastReading = sensor.readings[sensor.readings.length - 1];
                const lastTime = lastReading ? new Date(lastReading.timestamp) : null;
                
                // Informação de agrupamento
                const agrupamentoInfo = lastReading?.agrupamento ? 
                    ` • ${lastReading.agrupamento.leituras_agrupadas} leituras (${lastReading.agrupamento.tipo})` : '';
                
                html += `
                    <div class="device-status" style="margin-bottom: var(--spacing-sm);">
                        <div class="status-dot ${sensor.isOnline ? '' : 'offline'}"></div>
                        <div style="flex: 1;">
                            <strong>${sensor.name}</strong>
                            <p style="margin: 0; font-size: 0.875rem; color: var(--text-gray);">
                                ${sensor.location} • ${sensor.isOnline ? 'Online' : 'Offline'}
                                ${lastTime ? `• ${lastTime.toLocaleString('pt-BR', { 
                                    day: '2-digit', 
                                    month: '2-digit', 
                                    hour: '2-digit', 
                                    minute: '2-digit' 
                                })}` : '• Sem leituras'}${agrupamentoInfo}
                            </p>
                        </div>
                        ${lastReading ? `
                            <div style="text-align: right; font-size: 0.875rem;">
                                <div style="font-weight: 600; color: var(--dark-gray);">${lastReading.umidade_solo.toFixed(1)}%</div>
                                <div style="color: var(--text-gray); font-size: 0.75rem;">Umidade Solo</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            });
            
            html += '</div>';
            container.innerHTML = html;
        }
        
        function updateLatestReadings() {
            const container = document.getElementById('latestReadings');
            
            if (Object.keys(sensorsDataByDevice).length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <i class="fas fa-chart-line"></i>
                        <h4>Nenhuma leitura disponível</h4>
                        <p>Os dados dos sensores aparecerão aqui quando disponíveis</p>
                    </div>
                `;
                return;
            }
            
            // Coletar últimas leituras de todos os sensores
            let allReadings = [];
            
            Object.entries(sensorsDataByDevice).forEach(([deviceKey, sensor]) => {
                // Pegar últimas 3 leituras de cada sensor
                const recentReadings = sensor.readings.slice(-3).reverse();
                
                recentReadings.forEach(reading => {
                    allReadings.push({
                        ...reading,
                        deviceName: sensor.name,
                        deviceLocation: sensor.location,
                        deviceKey: deviceKey
                    });
                });
            });
            
            // Ordenar por timestamp (mais recentes primeiro)
            allReadings.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            
            // Mostrar apenas os 10 mais recentes
            const recentReadings = allReadings.slice(0, 10);
            
            let html = '';
            recentReadings.forEach(reading => {
                const timestamp = new Date(reading.timestamp);
                const formattedTime = timestamp.toLocaleString('pt-BR', {
                    day: '2-digit',
                    month: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                });
                
                html += `
                    <div class="reading-item">
                        <div class="reading-info">
                            <div class="reading-icon humidity">
                                <i class="fas fa-thermometer-half"></i>
                            </div>
                            <div class="reading-details">
                                <h6>Umidade do Solo</h6>
                                <p>${reading.deviceName} - ${reading.deviceLocation}</p>
                            </div>
                        </div>
                        <div class="reading-values">
                            <div class="reading-value">${reading.umidade_solo.toFixed(1)}%</div>
                            <div class="reading-time">${formattedTime}</div>
                        </div>
                    </div>
                    <div class="reading-item">
                        <div class="reading-info">
                            <div class="reading-icon rain">
                                <i class="fas fa-cloud-rain"></i>
                            </div>
                            <div class="reading-details">
                                <h6>Quantidade de Chuva</h6>
                                <p>${reading.deviceName} - Pluviômetro</p>
                            </div>
                        </div>
                        <div class="reading-values">
                            <div class="reading-value">${reading.quantidade_chuva.toFixed(1)}mm</div>
                            <div class="reading-time">${formattedTime}</div>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        function initializeCharts() {
            // Configuração comum dos gráficos
            Chart.defaults.font.family = 'Inter, sans-serif';
            Chart.defaults.color = '#4a5568';
            
            // Gráfico de Umidade
            const humidityCtx = document.getElementById('humidityChart').getContext('2d');
            humidityChart = new Chart(humidityCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Umidade do Solo (%)',
                        data: [],
                        borderColor: '#3182ce',
                        backgroundColor: 'rgba(49, 130, 206, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    layout: {
                        padding: {
                            top: 10,
                            bottom: 30,
                            left: 10,
                            right: 10
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: {
                                usePointStyle: true,
                                padding: 20,
                                font: {
                                    size: 12,
                                    family: 'Inter, sans-serif'
                                }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0,0,0,0.8)',
                            titleColor: 'white',
                            bodyColor: 'white',
                            callbacks: {
                                footer: function(context) {
                                    // Adicionar informações de agrupamento se disponível
                                    if (context.length > 0) {
                                        const dataIndex = context[0].dataIndex;
                                        const datasetIndex = context[0].datasetIndex;
                                        const chart = context[0].chart;
                                        const dataset = chart.data.datasets[datasetIndex];
                                        
                                        // Verificar se há informações de agrupamento armazenadas
                                        if (dataset.agrupamentoInfo && dataset.agrupamentoInfo[dataIndex]) {
                                            const info = dataset.agrupamentoInfo[dataIndex];
                                            return [
                                                '',
                                                `📊 ${info.tipo}`,
                                                `📈 ${info.leituras_agrupadas} leituras agrupadas`
                                            ];
                                        }
                                    }
                                    return [];
                                }
                            }
                        },
                        zoom: {
                            zoom: {
                                wheel: {
                                    enabled: true
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'x'
                            },
                            pan: {
                                enabled: true,
                                mode: 'x'
                            },
                            limits: {
                                x: {min: 'original', max: 'original'}
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                }
                            }
                        },
                        x: {
                            display: true
                        }
                    },
                    elements: {
                        point: {
                            radius: 3,
                            hoverRadius: 6
                        }
                    }
                }
            });
            
            // Gráfico de Chuva
            const rainCtx = document.getElementById('rainChart').getContext('2d');
            rainChart = new Chart(rainCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Quantidade de Chuva (mm)',
                        data: [],
                        borderColor: '#7fb069',
                        backgroundColor: 'rgba(127, 176, 105, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    layout: {
                        padding: {
                            top: 10,
                            bottom: 30,
                            left: 10,
                            right: 10
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: {
                                usePointStyle: true,
                                padding: 20,
                                font: {
                                    size: 12,
                                    family: 'Inter, sans-serif'
                                }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0,0,0,0.8)',
                            titleColor: 'white',
                            bodyColor: 'white',
                            callbacks: {
                                footer: function(context) {
                                    // Adicionar informações de agrupamento se disponível
                                    if (context.length > 0) {
                                        const dataIndex = context[0].dataIndex;
                                        const datasetIndex = context[0].datasetIndex;
                                        const chart = context[0].chart;
                                        const dataset = chart.data.datasets[datasetIndex];
                                        
                                        // Verificar se há informações de agrupamento armazenadas
                                        if (dataset.agrupamentoInfo && dataset.agrupamentoInfo[dataIndex]) {
                                            const info = dataset.agrupamentoInfo[dataIndex];
                                            return [
                                                '',
                                                `📊 ${info.tipo}`,
                                                `📈 ${info.leituras_agrupadas} leituras agrupadas`
                                            ];
                                        }
                                    }
                                    return [];
                                }
                            }
                        },
                        zoom: {
                            zoom: {
                                wheel: {
                                    enabled: true
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'x'
                            },
                            pan: {
                                enabled: true,
                                mode: 'x'
                            },
                            limits: {
                                x: {min: 'original', max: 'original'}
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return value + 'mm';
                                }
                            }
                        },
                        x: {
                            display: true
                        }
                    },
                    elements: {
                        point: {
                            radius: 3,
                            hoverRadius: 6
                        }
                    }
                }
            });

            // Gráfico de Temperatura do Ar
            const airTempCtx = document.getElementById('airTempChart').getContext('2d');
            airTempChart = new Chart(airTempCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Temperatura do Ar (°C)',
                        data: [],
                        borderColor: '#e53e3e',
                        backgroundColor: 'rgba(229, 62, 62, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    layout: {
                        padding: {
                            top: 10,
                            bottom: 30,
                            left: 10,
                            right: 10
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: {
                                usePointStyle: true,
                                padding: 20,
                                font: {
                                    size: 12,
                                    family: 'Inter, sans-serif'
                                }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0,0,0,0.8)',
                            titleColor: 'white',
                            bodyColor: 'white'
                        },
                        zoom: {
                            zoom: {
                                wheel: {
                                    enabled: true
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'x'
                            },
                            pan: {
                                enabled: true,
                                mode: 'x'
                            },
                            limits: {
                                x: {min: 'original', max: 'original'}
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            ticks: {
                                callback: function(value) {
                                    return value + '°C';
                                }
                            }
                        },
                        x: {
                            display: true
                        }
                    },
                    elements: {
                        point: {
                            radius: 3,
                            hoverRadius: 6
                        }
                    }
                }
            });

            // Gráfico de Umidade do Ar
            const airHumidityCtx = document.getElementById('airHumidityChart').getContext('2d');
            airHumidityChart = new Chart(airHumidityCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Umidade do Ar (%)',
                        data: [],
                        borderColor: '#3182ce',
                        backgroundColor: 'rgba(49, 130, 206, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    layout: {
                        padding: {
                            top: 10,
                            bottom: 30,
                            left: 10,
                            right: 10
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: {
                                usePointStyle: true,
                                padding: 20,
                                font: {
                                    size: 12,
                                    family: 'Inter, sans-serif'
                                }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0,0,0,0.8)',
                            titleColor: 'white',
                            bodyColor: 'white'
                        },
                        zoom: {
                            zoom: {
                                wheel: {
                                    enabled: true
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'x'
                            },
                            pan: {
                                enabled: true,
                                mode: 'x'
                            },
                            limits: {
                                x: {min: 'original', max: 'original'}
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                }
                            }
                        },
                        x: {
                            display: true
                        }
                    },
                    elements: {
                        point: {
                            radius: 3,
                            hoverRadius: 6
                        }
                    }
                }
            });

            // Gráfico de Vento
            const windCtx = document.getElementById('windChart').getContext('2d');
            windChart = new Chart(windCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    layout: {
                        padding: {
                            top: 10,
                            bottom: 30,
                            left: 10,
                            right: 10
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: {
                                usePointStyle: true,
                                padding: 20,
                                font: {
                                    size: 12,
                                    family: 'Inter, sans-serif'
                                }
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0,0,0,0.8)',
                            titleColor: 'white',
                            bodyColor: 'white'
                        },
                        zoom: {
                            zoom: {
                                wheel: {
                                    enabled: true
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'x'
                            },
                            pan: {
                                enabled: true,
                                mode: 'x'
                            },
                            limits: {
                                x: {min: 'original', max: 'original'}
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return value + 'km/h';
                                }
                            }
                        },
                        y1: {
                            position: 'right',
                            min: 0,
                            max: 360,
                            grid: {
                                drawOnChartArea: false
                            },
                            ticks: {
                                callback: function(value) {
                                    const cardinal = degreesToCardinalPT(value);
                                    return cardinal || value + '°';
                                }
                            }
                        },
                        x: {
                            display: true
                        }
                    },
                    elements: {
                        point: {
                            radius: 3,
                            hoverRadius: 6
                        }
                    }
                }
            });
            
            // Gráfico de Média Diária de Umidade
            const humidityAvgCtx = document.getElementById('humidityAvgChart').getContext('2d');
            humidityAvgChart = new Chart(humidityAvgCtx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0,0,0,0.8)',
                            titleColor: 'white',
                            bodyColor: 'white',
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}%`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                }
                            }
                        },
                        x: {
                            display: true
                        }
                    }
                }
            });

            // Gráfico de Total Diário de Chuva
            const rainAvgCtx = document.getElementById('rainAvgChart').getContext('2d');
            rainAvgChart = new Chart(rainAvgCtx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0,0,0,0.8)',
                            titleColor: 'white',
                            bodyColor: 'white',
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}mm`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: function(value) {
                                    return value + 'mm';
                                }
                            }
                        },
                        x: {
                            display: true
                        }
                    }
                }
            });
            
            // Aplicar preferências salvas do localStorage aos gráficos recém-criados
            loadChartPreferences();
            
            updateCharts();
        }
        
        async function updateCharts() {
            // Sistema otimizado: identificar todos os períodos necessários
            const periods = new Set();
            
            // Coletar períodos de cada gráfico
            const humidityPeriod = document.getElementById('humidityFilter')?.value || '24h';
            const rainPeriod = document.getElementById('rainFilter')?.value || '24h';
            const airTempPeriod = document.getElementById('airTempFilter')?.value || '24h';
            const airHumidityPeriod = document.getElementById('airHumidityFilter')?.value || '24h';
            const windPeriod = document.getElementById('windFilter')?.value || '24h';
            
            periods.add(humidityPeriod);
            periods.add(rainPeriod);
            periods.add(airTempPeriod);
            periods.add(airHumidityPeriod);
            periods.add(windPeriod);
            
            try {
                // Pré-carregar todos os períodos necessários
                console.log(`📊 Pré-carregando ${periods.size} período(s) único(s):`, Array.from(periods));
                await Promise.all(Array.from(periods).map(p => fetchSharedHistoryData(p)));
                
                // Atualizar todos os gráficos em paralelo usando dados em cache
                await Promise.all([
                    updateHumidityChart(),
                    updateRainChart(),
                    updateAirTempChart(),
                    updateAirHumidityChart(),
                    updateWindChart()
                ]);
                
                console.log(`✅ Gráficos atualizados (${periods.size} requisição(ões) à API)`);
                
            } catch (error) {
                console.error('Erro ao atualizar gráficos:', error);
            }
        }
        
        async function updateHumidityChart() {
            // Verificar se o gráfico foi inicializado
            if (!humidityChart) {
                console.warn('Gráfico de umidade não foi inicializado ainda');
                return;
            }
            
            const filter = document.getElementById('humidityFilter').value;
            
            // Resetar zoom ao mudar de período
            if (humidityChart.resetZoom) {
                humidityChart.resetZoom();
            }
            
            // Salvar período selecionado
            chartConfigs.humidity.period = filter;
            saveChartPreferences();
            
            const colors = [
                '#3182ce', '#38a169', '#e53e3e', '#f6ad55', 
                '#9f7aea', '#00d9ff', '#ff6b6b', '#4ecdc4'
            ];
            
            try {
                // Usar dados compartilhados em vez de fazer nova requisição
                const historyData = await fetchSharedHistoryData(filter);
                
                // Processar dados para o gráfico
                if (!historyData || historyData.length === 0) {
                    humidityChart.data.labels = [];
                    humidityChart.data.datasets = [];
                    humidityChart.update();
                    return;
                }
                
                // Agrupar dados por device_key
                const dataByDevice = {};
                historyData.forEach(reading => {
                    const deviceKey = getReadingDeviceKey(reading);
                    if (!deviceKey) {
                        return;
                    }
                    if (!dataByDevice[deviceKey]) {
                        // Usar o nome do sensor da API se disponível, senão usar o nome do sensorsDataByDevice ou gerar
                        const sensorName = reading.sensor_id?.nome || 
                                         sensorsDataByDevice[deviceKey]?.name || 
                                         generateDeviceName(deviceKey).name;
                        dataByDevice[deviceKey] = {
                            name: sensorName,
                            location: sensorsDataByDevice[deviceKey]?.location || generateDeviceName(deviceKey).location,
                            readings: []
                        };
                    }
                    dataByDevice[deviceKey].readings.push(reading);
                });
                
                // Coletar todos os timestamps únicos
                let allTimestamps = new Set();
                Object.values(dataByDevice).forEach(sensor => {
                    sensor.readings.forEach(reading => {
                        allTimestamps.add(reading.timestamp);
                    });
                });
                
                // Converter para array ordenado
                let timestamps = Array.from(allTimestamps).sort();
                
                // Aplicar limite de registros APENAS se o filtro for '24h' (tempo real)
                if (filter === '24h') {
                    const maxRecords = chartConfigs.humidity.maxRecords || 100;
                    if (timestamps.length > maxRecords) {
                        timestamps = timestamps.slice(-maxRecords);
                    }
                }
                
                // Criar labels para o eixo X
                humidityChart.data.labels = timestamps.map(timestamp => {
                    const date = new Date(timestamp);
                    if (filter === '24h') {
                        // Mostrar dia e hora para evitar ambiguidade quando há dados de múltiplos dias
                        return date.toLocaleString('pt-BR', { 
                            day: '2-digit', 
                            month: '2-digit',
                            hour: '2-digit', 
                            minute: '2-digit' 
                        });
                    } else if (filter === 'all') {
                        return date.toLocaleDateString('pt-BR', { day: '2-digit', month: 'short', year: '2-digit' });
                    } else {
                        return date.toLocaleDateString('pt-BR', { month: 'short', day: '2-digit' });
                    }
                });
                
                // Limpar datasets anteriores
                humidityChart.data.datasets = [];
                
                // Criar dataset para cada sensor
                let colorIndex = 0;
                Object.entries(dataByDevice).forEach(([deviceKey, sensor]) => {
                    // Criar array de dados e informações de agrupamento alinhados com os timestamps
                    const data = [];
                    const agrupamentoInfo = [];
                    
                    timestamps.forEach(timestamp => {
                        const reading = sensor.readings.find(r => r.timestamp === timestamp);
                        data.push(reading ? reading.umidade_solo : null);
                        
                        // Armazenar informações de agrupamento para cada ponto
                        if (reading?.agrupamento) {
                            agrupamentoInfo.push({
                                tipo: reading.agrupamento.tipo,
                                leituras_agrupadas: reading.agrupamento.leituras_agrupadas,
                                data_local: reading.agrupamento.data_local
                            });
                        } else {
                            agrupamentoInfo.push(null);
                        }
                    });
                    
                    const color = colors[colorIndex % colors.length];
                    
                    // Adicionar dataset para este sensor
                    humidityChart.data.datasets.push({
                        label: sensor.name, // Apenas o nome do sensor
                        data: data,
                        borderColor: color,
                        backgroundColor: color + '20',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.4,
                        spanGaps: true,
                        pointRadius: 3,
                        pointHoverRadius: 6,
                        agrupamentoInfo: agrupamentoInfo // Armazenar info de agrupamento no dataset
                    });
                    
                    colorIndex++;
                });
                
                // Aplicar preferências salvas (tipo de gráfico, fill, pontos, etc)
                applyChartPreferencesToSingleChart('humidity');
                
                humidityChart.update('none'); // Use 'none' para evitar animação que pode causar problemas
                
                // Processar dados globalmente para estatísticas e status (apenas no primeiro carregamento)
                processMultiSensorData(historyData);
                updateMultiSensorStatistics();
                updateMultiDeviceStatus();
                updateLatestReadings();
                
            } catch (error) {
                console.error('Erro ao atualizar gráfico de umidade:', error);
                // Limpar gráfico em caso de erro
                humidityChart.data.labels = [];
                humidityChart.data.datasets = [];
                humidityChart.update();
            }
        }
        
        async function updateRainChart() {
            // Verificar se o gráfico foi inicializado
            if (!rainChart) {
                console.warn('Gráfico de chuva não foi inicializado ainda');
                return;
            }
            
            const filter = document.getElementById('rainFilter').value;
            
            // Resetar zoom ao mudar de período
            if (rainChart.resetZoom) {
                rainChart.resetZoom();
            }
            
            // Salvar período selecionado
            chartConfigs.rain.period = filter;
            saveChartPreferences();
            
            const colors = [
                '#7fb069', '#38a169', '#2d5a27', '#68d391', 
                '#48bb78', '#22543d', '#9ae6b4', '#276749'
            ];
            
            try {
                // Usar dados compartilhados em vez de fazer nova requisição
                const historyData = await fetchSharedHistoryData(filter);
                
                // Processar dados para o gráfico
                if (!historyData || historyData.length === 0) {
                    rainChart.data.labels = [];
                    rainChart.data.datasets = [];
                    rainChart.update();
                    return;
                }
                
                // Agrupar dados por device_key
                const dataByDevice = {};
                historyData.forEach(reading => {
                    const deviceKey = getReadingDeviceKey(reading);
                    if (!deviceKey) {
                        return;
                    }
                    if (!dataByDevice[deviceKey]) {
                        // Usar o nome do sensor da API se disponível, senão usar o nome do sensorsDataByDevice ou gerar
                        const sensorName = reading.sensor_id?.nome || 
                                         sensorsDataByDevice[deviceKey]?.name || 
                                         generateDeviceName(deviceKey).name;
                        dataByDevice[deviceKey] = {
                            name: sensorName,
                            readings: []
                        };
                    }
                    dataByDevice[deviceKey].readings.push(reading);
                });
                
                // Coletar todos os timestamps únicos
                let allTimestamps = new Set();
                Object.values(dataByDevice).forEach(sensor => {
                    sensor.readings.forEach(reading => {
                        allTimestamps.add(reading.timestamp);
                    });
                });
                
                // Converter para array ordenado
                let timestamps = Array.from(allTimestamps).sort();
                
                // Aplicar limite de registros APENAS se o filtro for '24h' (tempo real)
                if (filter === '24h') {
                    const maxRecords = chartConfigs.rain.maxRecords || 100;
                    if (timestamps.length > maxRecords) {
                        timestamps = timestamps.slice(-maxRecords);
                    }
                }
                
                // Criar labels para o eixo X
                rainChart.data.labels = timestamps.map(timestamp => {
                    const date = new Date(timestamp);
                    if (filter === '24h') {
                        return date.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
                    } else if (filter === '7d') {
                        return date.toLocaleDateString('pt-BR', { weekday: 'short', day: '2-digit', month: 'short' });
                    } else if (filter === '30d') {
                        return date.toLocaleDateString('pt-BR', { day: '2-digit', month: 'short' });
                    } else if (filter === 'all') {
                        return date.toLocaleDateString('pt-BR', { day: '2-digit', month: 'short', year: '2-digit' });
                    } else {
                        return date.toLocaleDateString('pt-BR', { day: '2-digit', month: 'short' });
                    }
                });
                
                // Limpar datasets anteriores
                rainChart.data.datasets = [];
                
                // Criar dataset para cada sensor
                let colorIndex = 0;
                Object.entries(dataByDevice).forEach(([deviceKey, sensor]) => {
                    // Criar array de dados e informações de agrupamento alinhados com os timestamps
                    const data = [];
                    const agrupamentoInfo = [];
                    
                    timestamps.forEach(timestamp => {
                        const reading = sensor.readings.find(r => r.timestamp === timestamp);
                        data.push(reading ? reading.quantidade_chuva : null);
                        
                        // Armazenar informações de agrupamento para cada ponto
                        if (reading?.agrupamento) {
                            agrupamentoInfo.push({
                                tipo: reading.agrupamento.tipo,
                                leituras_agrupadas: reading.agrupamento.leituras_agrupadas,
                                data_local: reading.agrupamento.data_local
                            });
                        } else {
                            agrupamentoInfo.push(null);
                        }
                    });
                    
                    const color = colors[colorIndex % colors.length];
                    
                    // Adicionar dataset para este sensor
                    rainChart.data.datasets.push({
                        label: sensor.name,
                        data: data,
                        borderColor: color,
                        backgroundColor: color + '20',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 3,
                        pointHoverRadius: 6,
                        agrupamentoInfo: agrupamentoInfo // Armazenar info de agrupamento no dataset
                    });
                    
                    colorIndex++;
                });
                
                // Aplicar preferências salvas (tipo de gráfico, fill, pontos, etc)
                applyChartPreferencesToSingleChart('rain');
                
                rainChart.update('none'); // Use 'none' para evitar animação que pode causar problemas
                
                // Calcular e atualizar card de precipitação baseado no período do gráfico
                let totalRainPeriod = 0;
                Object.values(dataByDevice).forEach(sensor => {
                    // Para cada sensor, pegar a última leitura do período (valor acumulado)
                    if (sensor.readings.length > 0) {
                        sensor.readings.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                        totalRainPeriod += sensor.readings[0].quantidade_chuva || 0;
                    }
                });
                document.getElementById('totalRain').textContent = totalRainPeriod.toFixed(1) + 'mm';
                
            } catch (error) {
                console.error('Erro ao atualizar gráfico de chuva:', error);
                // Limpar gráfico em caso de erro
                rainChart.data.labels = [];
                rainChart.data.datasets = [];
                rainChart.update();
            }
        }

        async function updateAirTempChart() {
            if (!airTempChart) {
                console.warn('Gráfico de temperatura do ar não foi inicializado ainda');
                return;
            }

            const filter = document.getElementById('airTempFilter').value;

            if (airTempChart.resetZoom) {
                airTempChart.resetZoom();
            }

            chartConfigs.airTemp.period = filter;
            saveChartPreferences();

            const colors = [
                '#e53e3e', '#dd6b20', '#d53f8c', '#c05621',
                '#9b2c2c', '#ed8936', '#f56565', '#feb2b2'
            ];

            try {
                // Usar dados compartilhados em vez de fazer nova requisição
                const historyData = await fetchSharedHistoryData(filter);

                if (!historyData || historyData.length === 0) {
                    airTempChart.data.labels = [];
                    airTempChart.data.datasets = [];
                    airTempChart.update();
                    return;
                }

                const dataByDevice = {};
                historyData.forEach(reading => {
                    const deviceKey = getReadingDeviceKey(reading);
                    if (!deviceKey) {
                        return;
                    }
                    if (!dataByDevice[deviceKey]) {
                        const sensorName = reading.sensor_id?.nome ||
                            sensorsDataByDevice[deviceKey]?.name ||
                            generateDeviceName(deviceKey).name;
                        dataByDevice[deviceKey] = {
                            name: sensorName,
                            readings: []
                        };
                    }
                    dataByDevice[deviceKey].readings.push(reading);
                });

                let allTimestamps = new Set();
                Object.values(dataByDevice).forEach(sensor => {
                    sensor.readings.forEach(reading => {
                        allTimestamps.add(reading.timestamp);
                    });
                });

                let timestamps = Array.from(allTimestamps).sort();

                if (filter === '24h') {
                    const maxRecords = chartConfigs.airTemp.maxRecords || 100;
                    if (timestamps.length > maxRecords) {
                        timestamps = timestamps.slice(-maxRecords);
                    }
                }

                airTempChart.data.labels = timestamps.map(timestamp => {
                    const date = new Date(timestamp);
                    if (filter === '24h') {
                        return date.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
                    } else if (filter === '7d') {
                        return date.toLocaleDateString('pt-BR', { weekday: 'short', day: '2-digit', month: 'short' });
                    } else if (filter === '30d') {
                        return date.toLocaleDateString('pt-BR', { day: '2-digit', month: 'short' });
                    } else if (filter === 'all') {
                        return date.toLocaleDateString('pt-BR', { day: '2-digit', month: 'short', year: '2-digit' });
                    }
                    return date.toLocaleDateString('pt-BR', { day: '2-digit', month: 'short' });
                });

                airTempChart.data.datasets = [];

                let colorIndex = 0;
                Object.entries(dataByDevice).forEach(([deviceKey, sensor]) => {
                    const data = [];
                    const agrupamentoInfo = [];

                    timestamps.forEach(timestamp => {
                        const reading = sensor.readings.find(r => r.timestamp === timestamp);
                        const value = reading ? parseFloat(reading.temperatura_ar || reading.temperatura) : null;
                        data.push(Number.isFinite(value) ? value : null);

                        if (reading?.agrupamento) {
                            agrupamentoInfo.push({
                                tipo: reading.agrupamento.tipo,
                                leituras_agrupadas: reading.agrupamento.leituras_agrupadas,
                                data_local: reading.agrupamento.data_local
                            });
                        } else {
                            agrupamentoInfo.push(null);
                        }
                    });

                    const color = colors[colorIndex % colors.length];

                    airTempChart.data.datasets.push({
                        label: sensor.name,
                        data: data,
                        borderColor: color,
                        backgroundColor: color + '20',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        spanGaps: true,
                        pointRadius: 3,
                        pointHoverRadius: 6,
                        agrupamentoInfo: agrupamentoInfo
                    });

                    colorIndex++;
                });

                applyChartPreferencesToSingleChart('airTemp');
                airTempChart.update('none');

            } catch (error) {
                console.error('Erro ao atualizar gráfico de temperatura do ar:', error);
                airTempChart.data.labels = [];
                airTempChart.data.datasets = [];
                airTempChart.update();
            }
        }

        async function updateAirHumidityChart() {
            if (!airHumidityChart) {
                console.warn('Gráfico de umidade do ar não foi inicializado ainda');
                return;
            }

            const filter = document.getElementById('airHumidityFilter').value;

            if (airHumidityChart.resetZoom) {
                airHumidityChart.resetZoom();
            }

            chartConfigs.airHumidity.period = filter;
            saveChartPreferences();

            const colors = [
                '#3182ce', '#2b6cb0', '#00b5d8', '#38b2ac',
                '#4c51bf', '#4299e1', '#63b3ed', '#90cdf4'
            ];

            try {
                // Usar dados compartilhados em vez de fazer nova requisição
                const historyData = await fetchSharedHistoryData(filter);

                if (!historyData || historyData.length === 0) {
                    airHumidityChart.data.labels = [];
                    airHumidityChart.data.datasets = [];
                    airHumidityChart.update();
                    return;
                }

                const dataByDevice = {};
                historyData.forEach(reading => {
                    const deviceKey = getReadingDeviceKey(reading);
                    if (!deviceKey) {
                        return;
                    }
                    if (!dataByDevice[deviceKey]) {
                        const sensorName = reading.sensor_id?.nome ||
                            sensorsDataByDevice[deviceKey]?.name ||
                            generateDeviceName(deviceKey).name;
                        dataByDevice[deviceKey] = {
                            name: sensorName,
                            readings: []
                        };
                    }
                    dataByDevice[deviceKey].readings.push(reading);
                });

                let allTimestamps = new Set();
                Object.values(dataByDevice).forEach(sensor => {
                    sensor.readings.forEach(reading => {
                        allTimestamps.add(reading.timestamp);
                    });
                });

                let timestamps = Array.from(allTimestamps).sort();

                if (filter === '24h') {
                    const maxRecords = chartConfigs.airHumidity.maxRecords || 100;
                    if (timestamps.length > maxRecords) {
                        timestamps = timestamps.slice(-maxRecords);
                    }
                }

                airHumidityChart.data.labels = timestamps.map(timestamp => {
                    const date = new Date(timestamp);
                    if (filter === '24h') {
                        return date.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
                    } else if (filter === '7d') {
                        return date.toLocaleDateString('pt-BR', { weekday: 'short', day: '2-digit', month: 'short' });
                    } else if (filter === '30d') {
                        return date.toLocaleDateString('pt-BR', { day: '2-digit', month: 'short' });
                    } else if (filter === 'all') {
                        return date.toLocaleDateString('pt-BR', { day: '2-digit', month: 'short', year: '2-digit' });
                    }
                    return date.toLocaleDateString('pt-BR', { day: '2-digit', month: 'short' });
                });

                airHumidityChart.data.datasets = [];

                let colorIndex = 0;
                Object.entries(dataByDevice).forEach(([deviceKey, sensor]) => {
                    const data = [];
                    const agrupamentoInfo = [];

                    timestamps.forEach(timestamp => {
                        const reading = sensor.readings.find(r => r.timestamp === timestamp);
                        const value = reading ? parseFloat(reading.umidade_relativa || reading.umidade_ar) : null;
                        data.push(Number.isFinite(value) ? value : null);

                        if (reading?.agrupamento) {
                            agrupamentoInfo.push({
                                tipo: reading.agrupamento.tipo,
                                leituras_agrupadas: reading.agrupamento.leituras_agrupadas,
                                data_local: reading.agrupamento.data_local
                            });
                        } else {
                            agrupamentoInfo.push(null);
                        }
                    });

                    const color = colors[colorIndex % colors.length];

                    airHumidityChart.data.datasets.push({
                        label: sensor.name,
                        data: data,
                        borderColor: color,
                        backgroundColor: color + '20',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        spanGaps: true,
                        pointRadius: 3,
                        pointHoverRadius: 6,
                        agrupamentoInfo: agrupamentoInfo
                    });

                    colorIndex++;
                });

                applyChartPreferencesToSingleChart('airHumidity');
                airHumidityChart.update('none');

            } catch (error) {
                console.error('Erro ao atualizar gráfico de umidade do ar:', error);
                airHumidityChart.data.labels = [];
                airHumidityChart.data.datasets = [];
                airHumidityChart.update();
            }
        }

        // Função para converter graus em direção cardeal em português
        function degreesToCardinalPT(degrees) {
            if (degrees === null || degrees === undefined || !Number.isFinite(degrees)) {
                return '';
            }
            const directions = ['N', 'NE', 'L', 'SE', 'S', 'SO', 'O', 'NO'];
            const index = Math.round(degrees / 45) % 8;
            return directions[index];
        }

        function getWindDirectionDegrees(reading) {
            if (!reading) {
                return null;
            }
            if (reading.direcao_vento_graus !== null && reading.direcao_vento_graus !== undefined) {
                return Number(reading.direcao_vento_graus);
            }
            if (reading.direcao_vento !== null && reading.direcao_vento !== undefined) {
                const numeric = Number(reading.direcao_vento);
                if (Number.isFinite(numeric)) {
                    return numeric;
                }
            }
            const cardinal = reading.direcao_vento_cardinal;
            if (cardinal) {
                if (window.WindUtils && typeof WindUtils.getWindRotation === 'function') {
                    return WindUtils.getWindRotation(cardinal);
                }
                // Mapear direções em português
                const map = {
                    N: 0,
                    NE: 45,
                    L: 90,
                    E: 90,
                    LESTE: 90,
                    SE: 135,
                    S: 180,
                    SO: 225,
                    SW: 225,
                    O: 270,
                    W: 270,
                    OESTE: 270,
                    NO: 315,
                    NW: 315
                };
                return map[cardinal.toUpperCase()] ?? null;
            }
            return null;
        }

        async function updateWindChart() {
            if (!windChart) {
                console.warn('Gráfico de vento não foi inicializado ainda');
                return;
            }

            const filter = document.getElementById('windFilter').value;

            if (windChart.resetZoom) {
                windChart.resetZoom();
            }

            chartConfigs.wind.period = filter;
            saveChartPreferences();

            const colors = [
                '#2b6cb0', '#2f855a', '#dd6b20', '#6b46c1',
                '#d53f8c', '#319795', '#4a5568', '#805ad5'
            ];

            try {
                // Usar dados compartilhados em vez de fazer nova requisição
                const historyData = await fetchSharedHistoryData(filter);

                if (!historyData || historyData.length === 0) {
                    windChart.data.labels = [];
                    windChart.data.datasets = [];
                    windChart.update();
                    return;
                }

                const dataByDevice = {};
                historyData.forEach(reading => {
                    const deviceKey = getReadingDeviceKey(reading);
                    if (!deviceKey) {
                        return;
                    }
                    if (!dataByDevice[deviceKey]) {
                        const sensorName = reading.sensor_id?.nome ||
                            sensorsDataByDevice[deviceKey]?.name ||
                            generateDeviceName(deviceKey).name;
                        dataByDevice[deviceKey] = {
                            name: sensorName,
                            readings: []
                        };
                    }
                    dataByDevice[deviceKey].readings.push(reading);
                });

                let allTimestamps = new Set();
                Object.values(dataByDevice).forEach(sensor => {
                    sensor.readings.forEach(reading => {
                        allTimestamps.add(reading.timestamp);
                    });
                });

                let timestamps = Array.from(allTimestamps).sort();

                if (filter === '24h') {
                    const maxRecords = chartConfigs.wind.maxRecords || 100;
                    if (timestamps.length > maxRecords) {
                        timestamps = timestamps.slice(-maxRecords);
                    }
                }

                windChart.data.labels = timestamps.map(timestamp => {
                    const date = new Date(timestamp);
                    if (filter === '24h') {
                        return date.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
                    } else if (filter === '7d') {
                        return date.toLocaleDateString('pt-BR', { weekday: 'short', day: '2-digit', month: 'short' });
                    } else if (filter === '30d') {
                        return date.toLocaleDateString('pt-BR', { day: '2-digit', month: 'short' });
                    } else if (filter === 'all') {
                        return date.toLocaleDateString('pt-BR', { day: '2-digit', month: 'short', year: '2-digit' });
                    }
                    return date.toLocaleDateString('pt-BR', { day: '2-digit', month: 'short' });
                });

                windChart.data.datasets = [];

                let colorIndex = 0;
                Object.entries(dataByDevice).forEach(([deviceKey, sensor]) => {
                    const speedData = [];
                    const directionData = [];
                    const agrupamentoInfo = [];

                    timestamps.forEach(timestamp => {
                        const reading = sensor.readings.find(r => r.timestamp === timestamp);
                        const speedValue = reading ? parseFloat(reading.velocidade_vento) : null;
                        const directionValue = reading ? getWindDirectionDegrees(reading) : null;

                        speedData.push(Number.isFinite(speedValue) ? speedValue : null);
                        directionData.push(Number.isFinite(directionValue) ? directionValue : null);

                        if (reading?.agrupamento) {
                            agrupamentoInfo.push({
                                tipo: reading.agrupamento.tipo,
                                leituras_agrupadas: reading.agrupamento.leituras_agrupadas,
                                data_local: reading.agrupamento.data_local
                            });
                        } else {
                            agrupamentoInfo.push(null);
                        }
                    });

                    const color = colors[colorIndex % colors.length];

                    windChart.data.datasets.push({
                        label: `${sensor.name} - Velocidade (km/h)`,
                        data: speedData,
                        borderColor: color,
                        backgroundColor: color + '20',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        spanGaps: true,
                        pointRadius: 3,
                        pointHoverRadius: 6,
                        yAxisID: 'y',
                        agrupamentoInfo: agrupamentoInfo
                    });

                    // Usar cor diferente para direção (tom mais escuro/roxo)
                    const directionColor = '#8b5cf6'; // roxo
                    
                    windChart.data.datasets.push({
                        label: `${sensor.name} - Direção`,
                        data: directionData,
                        borderColor: directionColor,
                        backgroundColor: directionColor + '10',
                        borderWidth: 2,
                        fill: false,
                        tension: 0.4,
                        spanGaps: true,
                        pointRadius: 3,
                        pointHoverRadius: 6,
                        borderDash: [6, 4],
                        yAxisID: 'y1',
                        agrupamentoInfo: agrupamentoInfo
                    });

                    colorIndex++;
                });

                applyChartPreferencesToSingleChart('wind');
                windChart.update('none');

            } catch (error) {
                console.error('Erro ao atualizar gráfico de vento:', error);
                windChart.data.labels = [];
                windChart.data.datasets = [];
                windChart.update();
            }
        }
        
        async function updateHumidityAvgChart() {
            if (!humidityAvgChart) return;
            
            const filter = document.getElementById('humidityAvgFilter').value;
            
            // Resetar zoom ao mudar de período
            if (humidityAvgChart.resetZoom) {
                humidityAvgChart.resetZoom();
            }
            
            // Salvar período selecionado
            chartConfigs.humidityAvg.period = filter;
            saveChartPreferences();
            
            const colors = [
                '#3182ce', '#38a169', '#e53e3e', '#f6ad55', 
                '#9f7aea', '#00d9ff', '#ff6b6b', '#4ecdc4'
            ];
            
            try {
                const period = filter === 'all' ? null : filter;
                
                // Usar cache compartilhado para períodos conhecidos
                let historyData;
                if (period && ['24h', '7d', '30d'].includes(period)) {
                    historyData = await fetchSharedHistoryData(period);
                } else {
                    // Para 'all' ou períodos especiais, fazer requisição direta
                    const companyId = window.adminViewCompanyId || adminCompanyId || AuthManager.getCompanyId();
                    const response = await ApiClient.getSensorsHistory(companyId, period);
                    historyData = response?.dados || response || [];
                }
                
                if (!historyData || historyData.length === 0) {
                    humidityAvgChart.data.labels = [];
                    humidityAvgChart.data.datasets = [];
                    humidityAvgChart.update();
                    return;
                }
                
                // Agrupar dados por device_key e dia
                const dataByDeviceAndDay = {};
                
                historyData.forEach(reading => {
                    const deviceKey = getReadingDeviceKey(reading);
                    if (!deviceKey) {
                        return;
                    }
                    const date = new Date(reading.timestamp);
                    const dayKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
                    
                    if (!dataByDeviceAndDay[deviceKey]) {
                        dataByDeviceAndDay[deviceKey] = {};
                    }
                    
                    if (!dataByDeviceAndDay[deviceKey][dayKey]) {
                        dataByDeviceAndDay[deviceKey][dayKey] = {
                            sum: 0,
                            count: 0
                        };
                    }
                    
                    const humidity = parseFloat(reading.umidade_solo);
                    if (!isNaN(humidity)) {
                        dataByDeviceAndDay[deviceKey][dayKey].sum += humidity;
                        dataByDeviceAndDay[deviceKey][dayKey].count++;
                    }
                });
                
                // Coletar todos os dias únicos
                const allDays = new Set();
                Object.values(dataByDeviceAndDay).forEach(deviceData => {
                    Object.keys(deviceData).forEach(day => allDays.add(day));
                });
                
                const sortedDays = Array.from(allDays).sort();
                
                // Criar labels formatados
                humidityAvgChart.data.labels = sortedDays.map(day => {
                    const date = new Date(day);
                    return date.toLocaleDateString('pt-BR', { day: '2-digit', month: 'short' });
                });
                
                // Criar datasets
                humidityAvgChart.data.datasets = [];
                let colorIndex = 0;
                
                Object.entries(dataByDeviceAndDay).forEach(([deviceKey, dayData]) => {
                    // Buscar o nome do sensor nos dados processados ou gerar
                    const sensorName = sensorsDataByDevice[deviceKey]?.name || generateDeviceName(deviceKey).name;
                    const averages = sortedDays.map(day => {
                        if (dayData[day]) {
                            return dayData[day].sum / dayData[day].count;
                        }
                        return null;
                    });
                    
                    const color = colors[colorIndex % colors.length];
                    
                    humidityAvgChart.data.datasets.push({
                        label: sensorName, // Apenas o nome do sensor
                        data: averages,
                        backgroundColor: color,
                        borderColor: color,
                        borderWidth: 2,
                        fill: chartConfigs.humidityAvg.fill || false,
                        pointRadius: chartConfigs.humidityAvg.showPoints ? 3 : 0,
                        pointHoverRadius: chartConfigs.humidityAvg.showPoints ? 5 : 0,
                        tension: 0.4
                    });
                    
                    colorIndex++;
                });
                
                // Aplicar preferências de personalização
                applyChartPreferencesToSingleChart('humidityAvg');
                humidityAvgChart.update('none'); // Use 'none' para evitar animação que pode causar problemas
                
            } catch (error) {
                console.error('Erro ao atualizar gráfico de média de umidade:', error);
            }
        }

        async function updateRainAvgChart() {
            if (!rainAvgChart) return;
            
            const filter = document.getElementById('rainAvgFilter').value;
            
            // Resetar zoom ao mudar de período
            if (rainAvgChart.resetZoom) {
                rainAvgChart.resetZoom();
            }
            
            // Salvar período selecionado
            chartConfigs.rainAvg.period = filter;
            saveChartPreferences();
            
            const colors = [
                '#7fb069', '#38a169', '#2d5a27', '#68d391', 
                '#48bb78', '#22543d', '#9ae6b4', '#276749'
            ];
            
            try {
                const period = filter === 'all' ? null : filter;
                
                // Usar cache compartilhado para períodos conhecidos
                let historyData;
                if (period && ['24h', '7d', '30d'].includes(period)) {
                    historyData = await fetchSharedHistoryData(period);
                } else {
                    // Para 'all' ou períodos especiais, fazer requisição direta
                    const companyId = window.adminViewCompanyId || adminCompanyId || AuthManager.getCompanyId();
                    const response = await ApiClient.getSensorsHistory(companyId, period);
                    historyData = response?.dados || response || [];
                }
                
                if (!historyData || historyData.length === 0) {
                    rainAvgChart.data.labels = [];
                    rainAvgChart.data.datasets = [];
                    rainAvgChart.update();
                    return;
                }
                
                // Agrupar dados por device_key e dia (pegar o valor máximo do dia, pois é acumulado)
                const dataByDeviceAndDay = {};
                
                historyData.forEach(reading => {
                    const deviceKey = getReadingDeviceKey(reading);
                    if (!deviceKey) {
                        return;
                    }
                    const date = new Date(reading.timestamp);
                    const dayKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
                    
                    if (!dataByDeviceAndDay[deviceKey]) {
                        dataByDeviceAndDay[deviceKey] = {};
                    }
                    
                    const rain = parseFloat(reading.quantidade_chuva);
                    if (!isNaN(rain)) {
                        // Para chuva acumulada, pegamos o valor máximo do dia
                        if (!dataByDeviceAndDay[deviceKey][dayKey] || rain > dataByDeviceAndDay[deviceKey][dayKey]) {
                            dataByDeviceAndDay[deviceKey][dayKey] = rain;
                        }
                    }
                });
                
                // Coletar todos os dias únicos
                const allDays = new Set();
                Object.values(dataByDeviceAndDay).forEach(deviceData => {
                    Object.keys(deviceData).forEach(day => allDays.add(day));
                });
                
                const sortedDays = Array.from(allDays).sort();
                
                // Criar labels formatados
                rainAvgChart.data.labels = sortedDays.map(day => {
                    const date = new Date(day);
                    return date.toLocaleDateString('pt-BR', { day: '2-digit', month: 'short' });
                });
                
                // Criar datasets
                rainAvgChart.data.datasets = [];
                let colorIndex = 0;
                
                Object.entries(dataByDeviceAndDay).forEach(([deviceKey, dayData]) => {
                    const deviceName = generateDeviceName(deviceKey);
                    const dailyTotals = sortedDays.map(day => {
                        return dayData[day] !== undefined ? dayData[day] : null;
                    });
                    
                    const color = colors[colorIndex % colors.length];
                    
                    rainAvgChart.data.datasets.push({
                        label: `${deviceName.name}`,
                        data: dailyTotals,
                        backgroundColor: color,
                        borderColor: color,
                        borderWidth: 2,
                        fill: chartConfigs.rainAvg.fill || false,
                        pointRadius: chartConfigs.rainAvg.showPoints ? 3 : 0,
                        pointHoverRadius: chartConfigs.rainAvg.showPoints ? 5 : 0,
                        tension: 0.4
                    });
                    
                    colorIndex++;
                });
                
                // Aplicar preferências de personalização
                applyChartPreferencesToSingleChart('rainAvg');
                rainAvgChart.update('none'); // Use 'none' para evitar animação que pode causar problemas
                
            } catch (error) {
                console.error('Erro ao atualizar gráfico de total diário de chuva:', error);
            }
        }

        function groupReadingsByTimePeriod(readings, filter) {
            const groups = {};
            
            readings.forEach(reading => {
                const date = new Date(reading.timestamp);
                let key;
                
                if (filter === '24h') {
                    // Agrupar por hora
                    key = `${date.getHours().toString().padStart(2, '0')}:00`;
                } else if (filter === '7d') {
                    // Agrupar por dia
                    key = date.toLocaleDateString('pt-BR', { weekday: 'short', day: '2-digit' });
                } else if (filter === '30d') {
                    // Agrupar por dia
                    key = date.toLocaleDateString('pt-BR', { month: 'short', day: '2-digit' });
                } else if (filter === 'all') {
                    // Agrupar por semana
                    const weekStart = new Date(date);
                    weekStart.setDate(date.getDate() - date.getDay());
                    key = weekStart.toLocaleDateString('pt-BR', { month: 'short', day: '2-digit', year: '2-digit' });
                } else {
                    // Default: agrupar por dia
                    key = date.toLocaleDateString('pt-BR', { month: 'short', day: '2-digit' });
                }
                
                if (!groups[key]) {
                    groups[key] = {
                        byDevice: {}
                    };
                }
                
                // Agrupar por device_key para evitar somar leituras duplicadas do mesmo sensor
                const deviceKey = getReadingDeviceKey(reading);
                if (!deviceKey) {
                    return;
                }
                if (!groups[key].byDevice[deviceKey]) {
                    groups[key].byDevice[deviceKey] = [];
                }
                groups[key].byDevice[deviceKey].push({
                    timestamp: new Date(reading.timestamp),
                    rain: reading.quantidade_chuva
                });
            });
            
            // Converter para arrays ordenados
            const sortedKeys = Object.keys(groups).sort();
            const labels = sortedKeys;
            const totalRain = sortedKeys.map(key => {
                let periodTotal = 0;
                
                // Para cada dispositivo no período, pegar apenas a última leitura (valor acumulado)
                Object.values(groups[key].byDevice).forEach(deviceReadings => {
                    // Ordenar por timestamp
                    deviceReadings.sort((a, b) => b.timestamp - a.timestamp);
                    // Pegar a última leitura (mais recente) que já vem com valor acumulado
                    if (deviceReadings.length > 0) {
                        periodTotal += deviceReadings[0].rain;
                    }
                });
                
                return periodTotal;
            });
            
            return { labels, totalRain };
        }
        
        function filterDataByTime(data, filter) {
            // Se filter for "all", retornar todos os dados
            if (filter === 'all') {
                return data;
            }
            
            const now = new Date();
            let cutoff;
            
            switch (filter) {
                case '24h':
                    cutoff = new Date(now.getTime() - 24 * 60 * 60 * 1000);
                    break;
                case '7d':
                    cutoff = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
                    break;
                case '30d':
                    cutoff = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
                    break;
                default:
                    cutoff = new Date(now.getTime() - 24 * 60 * 60 * 1000);
            }
            
            return data.filter(item => new Date(item.timestamp) >= cutoff);
        }
        
        function setupEventListeners() {
            // Logout (com verificação de segurança)
            const logoutBtn = document.getElementById('logoutBtn');
            if (logoutBtn) {
                logoutBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    if (typeof AuthManager !== 'undefined' && AuthManager.logout) {
                        AuthManager.logout();
                    } else {
                        // Fallback se AuthManager não estiver disponível
                        window.location.href = '../index.html';
                    }
                });
            }
            
            // ===== ATUALIZAÇÃO AUTOMÁTICA COM INTERVALO DINÂMICO =====
            let autoRefreshTimer = null;
            
            function startAutoRefresh() {
                if (typeof loadDashboardData !== 'function') return;
                
                // Limpar timer anterior se existir
                if (autoRefreshTimer) {
                    clearInterval(autoRefreshTimer);
                    autoRefreshTimer = null;
                }
                
                // Carregar intervalo do localStorage ou usar 5 minutos como padrão
                const savedInterval = localStorage.getItem('dashboardRefreshInterval');
                const refreshInterval = savedInterval ? parseInt(savedInterval) : 5 * 60 * 1000;
                
                console.log(`🔄 Dashboard será atualizado automaticamente a cada ${refreshInterval}ms (${refreshInterval / 60000} minutos)`);
                
                // Iniciar novo timer
                autoRefreshTimer = setInterval(loadDashboardData, refreshInterval);
            }
            
            // Iniciar atualização automática
            startAutoRefresh();
            
            // Escutar mudanças de configuração de outras abas
            if ('BroadcastChannel' in window) {
                const configChannel = new BroadcastChannel('dashboard_config');
                
                configChannel.onmessage = (event) => {
                    if (event.data.type === 'refresh_interval_updated') {
                        console.log('📡 Recebida atualização de intervalo:', event.data.interval);
                        startAutoRefresh();
                    }
                };
            }
            
            // Fechar dropdowns ao clicar fora
            document.addEventListener('click', function(e) {
                if (!e.target.closest('.chart-control-btn') && !e.target.closest('.chart-settings-dropdown')) {
                    document.querySelectorAll('.chart-settings-dropdown').forEach(dropdown => {
                        dropdown.classList.remove('show');
                    });
                }
            });
            
            // Nota: loadChartPreferences() agora é chamada em initializeCharts()
            // após a criação dos gráficos, não aqui
        }
        
        // ===== FUNÇÕES DE PERSONALIZAÇÃO DE GRÁFICOS =====
        
        // Armazenamento de configurações
        const chartConfigs = {
            humidity: {
                type: 'line',  // Pode ser: 'line', 'area', 'bar'
                showGrid: true,
                showPoints: true,
                maxRecords: 100,  // Quantidade máxima de registros a exibir
                period: '24h'  // Período selecionado
            },
            rain: {
                type: 'line',  // Pode ser: 'line', 'area', 'bar'
                showGrid: true,
                showPoints: true,
                maxRecords: 100,  // Quantidade máxima de registros a exibir
                period: '24h'  // Período selecionado
            },
            airTemp: {
                type: 'line',
                showGrid: true,
                showPoints: true,
                maxRecords: 100,
                period: '24h'
            },
            airHumidity: {
                type: 'line',
                showGrid: true,
                showPoints: true,
                maxRecords: 100,
                period: '24h'
            },
            wind: {
                type: 'line',
                showGrid: true,
                showPoints: true,
                maxRecords: 100,
                period: '24h'
            },
            humidityAvg: {
                type: 'bar',  // Pode ser: 'line', 'area', 'bar'
                showGrid: true,
                showPoints: false,
                fill: false,
                maxRecords: 100,  // Não usado em gráficos de média diária
                period: '7d'  // Período selecionado
            },
            rainAvg: {
                type: 'bar',  // Pode ser: 'line', 'area', 'bar'
                showGrid: true,
                showPoints: false,
                fill: false,
                maxRecords: 100,  // Não usado em gráficos de média diária
                period: '7d'  // Período selecionado
            }
        };
        
        // Toggle do menu de configurações
        function toggleChartSettings(chartName) {
            const dropdown = document.getElementById(`${chartName}Settings`);
            const allDropdowns = document.querySelectorAll('.chart-settings-dropdown');
            
            // Fechar outros dropdowns
            allDropdowns.forEach(d => {
                if (d !== dropdown) {
                    d.classList.remove('show');
                }
            });
            
            // Toggle do dropdown atual
            dropdown.classList.toggle('show');
            
            console.log(`Toggle dropdown ${chartName}:`, dropdown.classList.contains('show') ? 'ABERTO' : 'FECHADO');
        }
        
        // Mudar tipo de gráfico
        function changeChartType(chartName, type) {
            console.log(`Mudando tipo de gráfico ${chartName} para:`, type);
            
            // Atualizar configuração
            chartConfigs[chartName].type = type;
            
            // Atualizar UI dos botões
            const container = document.getElementById(`${chartName}Settings`);
            container.querySelectorAll('.chart-type-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.type === type) {
                    btn.classList.add('active');
                }
            });
            
            // Aplicar mudança ao gráfico
            let chart;
            if (chartName === 'humidity') chart = humidityChart;
            else if (chartName === 'rain') chart = rainChart;
            else if (chartName === 'airTemp') chart = airTempChart;
            else if (chartName === 'airHumidity') chart = airHumidityChart;
            else if (chartName === 'wind') chart = windChart;
            else if (chartName === 'humidityAvg') chart = humidityAvgChart;
            else if (chartName === 'rainAvg') chart = rainAvgChart;
            
            if (!chart) {
                console.warn(`Gráfico ${chartName} não encontrado`);
                return;
            }
            
            // LÓGICA SIMPLES E DIRETA:
            // area = line com fill, line = line sem fill, bar = bar sem fill
            if (type === 'area') {
                chart.config.type = 'line';
                if (chart.data && chart.data.datasets) {
                    chart.data.datasets.forEach(dataset => {
                        dataset.fill = true;
                        dataset.backgroundColor = dataset.borderColor + '33';
                    });
                }
            } else if (type === 'bar') {
                chart.config.type = 'bar';
                if (chart.data && chart.data.datasets) {
                    chart.data.datasets.forEach(dataset => {
                        dataset.fill = false;
                    });
                }
            } else { // type === 'line'
                chart.config.type = 'line';
                if (chart.data && chart.data.datasets) {
                    chart.data.datasets.forEach(dataset => {
                        dataset.fill = false;
                    });
                }
            }
            
            chart.update();
            console.log(`Gráfico ${chartName} atualizado para tipo:`, type);
            saveChartPreferences();
        }
        
        // Toggle grid
        function toggleChartGrid(chartName) {
            const toggle = document.getElementById(`${chartName}GridToggle`);
            const isActive = toggle.classList.toggle('active');
            chartConfigs[chartName].showGrid = isActive;
            
            let chart;
            if (chartName === 'humidity') chart = humidityChart;
            else if (chartName === 'rain') chart = rainChart;
            else if (chartName === 'airTemp') chart = airTempChart;
            else if (chartName === 'airHumidity') chart = airHumidityChart;
            else if (chartName === 'wind') chart = windChart;
            else if (chartName === 'humidityAvg') chart = humidityAvgChart;
            else if (chartName === 'rainAvg') chart = rainAvgChart;
            
            if (chart && chart.options && chart.options.scales) {
                chart.options.scales.x.grid = { display: isActive };
                chart.options.scales.y.grid = { display: isActive };
                if (chart.options.scales.y1 && chart.options.scales.y1.grid) {
                    chart.options.scales.y1.grid.display = isActive;
                }
                chart.update();
            }
            
            console.log(`Grid ${chartName}:`, isActive ? 'ATIVADO' : 'DESATIVADO');
            saveChartPreferences();
        }
        
        // Toggle pontos
        function toggleChartPoints(chartName) {
            const toggle = document.getElementById(`${chartName}PointsToggle`);
            const isActive = toggle.classList.toggle('active');
            chartConfigs[chartName].showPoints = isActive;
            
            let chart;
            if (chartName === 'humidity') chart = humidityChart;
            else if (chartName === 'rain') chart = rainChart;
            else if (chartName === 'airTemp') chart = airTempChart;
            else if (chartName === 'airHumidity') chart = airHumidityChart;
            else if (chartName === 'wind') chart = windChart;
            else if (chartName === 'humidityAvg') chart = humidityAvgChart;
            else if (chartName === 'rainAvg') chart = rainAvgChart;
            
            if (chart && chart.data && chart.data.datasets) {
                chart.data.datasets.forEach(dataset => {
                    dataset.pointRadius = isActive ? 3 : 0;
                    dataset.pointHoverRadius = isActive ? 6 : 0;
                });
                chart.update();
            }
            
            console.log(`Pontos ${chartName}:`, isActive ? 'ATIVADO' : 'DESATIVADO');
            saveChartPreferences();
        }
        
        // Toggle preenchimento
        function toggleChartFill(chartName) {
            const toggle = document.getElementById(`${chartName}FillToggle`);
            const isActive = toggle.classList.toggle('active');
            
            // Se ativar fill, muda para 'area'. Se desativar, muda para 'line'
            const newType = isActive ? 'area' : 'line';
            chartConfigs[chartName].type = newType;
            
            // Atualizar UI dos botões de tipo
            const container = document.getElementById(`${chartName}Settings`);
            container.querySelectorAll('.chart-type-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.type === newType) {
                    btn.classList.add('active');
                }
            });
            
            let chart;
            if (chartName === 'humidity') chart = humidityChart;
            else if (chartName === 'rain') chart = rainChart;
            else if (chartName === 'airTemp') chart = airTempChart;
            else if (chartName === 'airHumidity') chart = airHumidityChart;
            else if (chartName === 'wind') chart = windChart;
            else if (chartName === 'humidityAvg') chart = humidityAvgChart;
            else if (chartName === 'rainAvg') chart = rainAvgChart;
            if (chart && chart.config && chart.config.type === 'line' && chart.data && chart.data.datasets) {
                chart.data.datasets.forEach(dataset => {
                    dataset.fill = isActive;
                    if (isActive) {
                        dataset.backgroundColor = dataset.borderColor + '20';
                    } else {
                        dataset.backgroundColor = 'transparent';
                    }
                });
                chart.update();
            }
            
            console.log(`Preenchimento ${chartName}:`, isActive ? 'ATIVADO (area)' : 'DESATIVADO (line)');
            saveChartPreferences();
        }
        
        // Alterar limite de registros
        function changeChartMaxRecords(chartName, value) {
            const maxRecords = parseInt(value);
            
            // Validar valor
            if (isNaN(maxRecords) || maxRecords < 10) {
                document.getElementById(`${chartName}MaxRecords`).value = 10;
                chartConfigs[chartName].maxRecords = 10;
            } else if (maxRecords > 10000) {
                document.getElementById(`${chartName}MaxRecords`).value = 10000;
                chartConfigs[chartName].maxRecords = 10000;
            } else {
                chartConfigs[chartName].maxRecords = maxRecords;
            }
            
            console.log(`Limite de registros ${chartName}:`, chartConfigs[chartName].maxRecords);
            saveChartPreferences();
            
            // Atualizar gráfico imediatamente
            if (chartName === 'humidity') {
                updateHumidityChart();
            } else if (chartName === 'rain') {
                updateRainChart();
            } else if (chartName === 'airTemp') {
                updateAirTempChart();
            } else if (chartName === 'airHumidity') {
                updateAirHumidityChart();
            } else if (chartName === 'wind') {
                updateWindChart();
            }
        }
        
        // Salvar preferências no localStorage
        function saveChartPreferences() {
            try {
                localStorage.setItem('chartPreferences', JSON.stringify(chartConfigs));
            } catch (error) {
                console.warn('Erro ao salvar preferências:', error);
            }
        }
        
        // Carregar preferências do localStorage
        function loadChartPreferences() {
            try {
                const saved = localStorage.getItem('chartPreferences');
                if (saved) {
                    const preferences = JSON.parse(saved);
                    Object.assign(chartConfigs, preferences);
                }
                
                // SEMPRE aplicar estados visuais (mesmo sem localStorage salvo)
                ['humidity', 'rain', 'airTemp', 'airHumidity', 'wind'].forEach(chartName => {
                    const config = chartConfigs[chartName];
                    
                    // Atualizar botões de tipo de gráfico
                    const typeButtons = document.querySelectorAll(`#${chartName}Settings .chart-type-btn`);
                    typeButtons.forEach(btn => {
                        if (btn.dataset.type === config.type) {
                            btn.classList.add('active');
                        } else {
                            btn.classList.remove('active');
                        }
                    });
                    
                    // Atualizar toggle de grid
                    const gridToggle = document.getElementById(`${chartName}GridToggle`);
                    if (gridToggle) {
                        if (config.showGrid) {
                            gridToggle.classList.add('active');
                        } else {
                            gridToggle.classList.remove('active');
                        }
                    }
                    
                    // Atualizar toggle de pontos
                    const pointsToggle = document.getElementById(`${chartName}PointsToggle`);
                    if (pointsToggle) {
                        if (config.showPoints) {
                            pointsToggle.classList.add('active');
                        } else {
                            pointsToggle.classList.remove('active');
                        }
                    }
                    
                    // Atualizar toggle de preenchimento baseado no tipo
                    const fillToggle = document.getElementById(`${chartName}FillToggle`);
                    if (fillToggle) {
                        if (config.type === 'area') {
                            fillToggle.classList.add('active');
                        } else {
                            fillToggle.classList.remove('active');
                        }
                    }
                    
                    // Atualizar campo de limite de registros
                    const maxRecordsInput = document.getElementById(`${chartName}MaxRecords`);
                    if (maxRecordsInput && config.maxRecords) {
                        maxRecordsInput.value = config.maxRecords;
                    }
                    
                    // Restaurar período selecionado no dropdown
                    const filterSelect = document.getElementById(`${chartName}Filter`);
                    if (filterSelect && config.period) {
                        filterSelect.value = config.period;
                    }
                });
                
                // Também para os gráficos de média
                ['humidityAvg', 'rainAvg'].forEach(chartName => {
                    const config = chartConfigs[chartName];
                    const filterSelect = document.getElementById(`${chartName}Filter`);
                    if (filterSelect && config.period) {
                        filterSelect.value = config.period;
                    }
                });
                
                console.log('Preferências de gráficos carregadas:', chartConfigs);
                
                // Aplicar preferências aos gráficos Chart.js
                applyChartPreferencesToCharts();
            } catch (error) {
                console.warn('Erro ao carregar preferências:', error);
            }
        }
        
        // Aplicar configurações salvas aos objetos Chart.js
        function applyChartPreferencesToCharts() {
            ['humidity', 'rain', 'airTemp', 'airHumidity', 'wind', 'humidityAvg', 'rainAvg'].forEach(chartName => {
                applyChartPreferencesToSingleChart(chartName);
            });
            
            console.log('Preferências aplicadas aos gráficos Chart.js');
        }
        
        // Aplicar configurações salvas a um gráfico específico (útil após atualização de dados)
        function applyChartPreferencesToSingleChart(chartName) {
            let chart;
            if (chartName === 'humidity') chart = humidityChart;
            else if (chartName === 'rain') chart = rainChart;
            else if (chartName === 'airTemp') chart = airTempChart;
            else if (chartName === 'airHumidity') chart = airHumidityChart;
            else if (chartName === 'wind') chart = windChart;
            else if (chartName === 'humidityAvg') chart = humidityAvgChart;
            else if (chartName === 'rainAvg') chart = rainAvgChart;
            
            const config = chartConfigs[chartName];
            
            if (!chart) {
                console.warn(`Gráfico ${chartName} ainda não foi inicializado`);
                return;
            }
            
            if (!chart.data || !chart.data.datasets || chart.data.datasets.length === 0) {
                console.warn(`Gráfico ${chartName} não possui datasets ainda`);
                return;
            }
            
            // LÓGICA SIMPLES E DIRETA baseada no tipo:
            // 'area' = line com fill true
            // 'line' = line com fill false  
            // 'bar' = bar com fill false
            
            if (config.type === 'area') {
                if (chart.config.type !== 'line') {
                    chart.config.type = 'line';
                }
                chart.data.datasets.forEach(dataset => {
                    dataset.fill = true;
                    // Usar backgroundColor existente ou criar um com opacidade
                    if (dataset.borderColor && !dataset.backgroundColor.includes('33')) {
                        dataset.backgroundColor = dataset.borderColor + '33';
                    }
                });
            } else if (config.type === 'bar') {
                if (chart.config.type !== 'bar') {
                    chart.config.type = 'bar';
                }
                chart.data.datasets.forEach(dataset => {
                    dataset.fill = false;
                });
            } else { // type === 'line'
                if (chart.config.type !== 'line') {
                    chart.config.type = 'line';
                }
                chart.data.datasets.forEach(dataset => {
                    dataset.fill = false;
                });
            }
            
            // Aplicar grid
            if (chart.options && chart.options.scales) {
                if (chart.options.scales.x && chart.options.scales.x.grid) {
                    chart.options.scales.x.grid.display = config.showGrid;
                }
                if (chart.options.scales.y && chart.options.scales.y.grid) {
                    chart.options.scales.y.grid.display = config.showGrid;
                }
                if (chart.options.scales.y1 && chart.options.scales.y1.grid) {
                    chart.options.scales.y1.grid.display = config.showGrid;
                }
            }
            
            // Aplicar pontos
            chart.data.datasets.forEach(dataset => {
                dataset.pointRadius = config.showPoints ? 3 : 0;
                dataset.pointHoverRadius = config.showPoints ? 6 : 0;
            });
            
            console.log(`Preferências aplicadas ao gráfico ${chartName}:`, config);
        }
        
        function setupMobileMenu() {
            try {
                const sidebarToggle = document.querySelector('[data-sidebar-toggle]');
                const sidebar = document.querySelector('.sidebar');
                const overlay = document.querySelector('[data-sidebar-overlay]');
                
                if (!sidebarToggle || !sidebar || !overlay) {
                    return;
                }
                
                // Configurar estado inicial do sidebar
                initializeSidebarState();
                
                // Toggle sidebar ao clicar no hamburguer
                sidebarToggle.addEventListener('click', function(e) {
                    e.preventDefault();
                    toggleSidebar();
                });
                
                // Fechar sidebar ao clicar no overlay
                overlay.addEventListener('click', function() {
                    if (sidebarAberto) fecharSidebar();
                });
                
                // Fechar sidebar com ESC
                document.addEventListener('keydown', function(e) {
                    if (e.key === 'Escape' && sidebarAberto) {
                        fecharSidebar();
                    }
                });
                
                // Fechar sidebar ao clicar em links (mobile)
                if (window.innerWidth <= 1024) {
                    const sidebarLinks = sidebar.querySelectorAll('.sidebar-nav-link:not(.disabled)');
                    sidebarLinks.forEach(link => {
                        link.addEventListener('click', function() {
                            if (sidebarAberto) {
                                setTimeout(() => fecharSidebar(), 150);
                            }
                        });
                    });
                }
            } catch (error) {
                // Silencioso - menu mobile não crítico
            }
        }
        
        function initializeSidebarState() {
            const sidebar = document.querySelector('.sidebar');
            const overlay = document.querySelector('[data-sidebar-overlay]');
            
            if (!sidebar || !overlay) return;
            
            // FORÇAR estado inicial fechado COMPLETAMENTE
            sidebarAberto = false;
            
            if (window.innerWidth <= 1024) {
                // FORÇAR sidebar para FORA da tela
                sidebar.style.cssText = `
                    position: fixed !important;
                    left: -300px !important;
                    top: 0 !important;
                    width: 280px !important;
                    height: 100vh !important;
                    z-index: -1 !important;
                    transform: translateX(-100%) !important;
                `;
                
                overlay.style.cssText = `
                    opacity: 0 !important;
                    visibility: hidden !important;
                    pointer-events: none !important;
                    z-index: -1 !important;
                `;
            }
            

        }
        
        // Variável simples para controlar estado
        let sidebarAberto = false;
        
        function toggleSidebar() {
            if (sidebarAberto) {
                fecharSidebar();
            } else {
                abrirSidebar();
            }
        }
        
        function abrirSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const overlay = document.querySelector('[data-sidebar-overlay]');
            const hamburger = document.querySelector('[data-sidebar-toggle]');
            
            // Forçar estilos inline - SIMPLES E DIRETO
            sidebar.style.cssText = `
                position: fixed !important;
                left: 0 !important;
                top: 0 !important;
                width: 280px !important;
                height: 100vh !important;
                z-index: 9999 !important;
                background: white !important;
                transform: translateX(0) !important;
                transition: transform 0.3s ease !important;
                box-shadow: 0 0 30px rgba(0,0,0,0.5) !important;
            `;
            
            overlay.style.cssText = `
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                width: 100% !important;
                height: 100% !important;
                background: rgba(0,0,0,0.5) !important;
                z-index: 998 !important;
                opacity: 1 !important;
                visibility: visible !important;
                pointer-events: auto !important;
            `;
            
            hamburger.classList.add('active');
            document.body.style.overflow = 'hidden';
            sidebarAberto = true;
        }
        
        function fecharSidebar() {
            const sidebar = document.querySelector('.sidebar');
            const overlay = document.querySelector('[data-sidebar-overlay]');
            const hamburger = document.querySelector('[data-sidebar-toggle]');
            
            // FORÇAR COMPLETAMENTE O FECHAMENTO
            sidebar.style.cssText = `
                position: fixed !important;
                left: -300px !important;
                top: 0 !important;
                width: 280px !important;
                height: 100vh !important;
                z-index: -1 !important;
                transform: translateX(-100%) !important;
                transition: all 0.3s ease !important;
            `;
            
            overlay.style.cssText = `
                opacity: 0 !important;
                visibility: hidden !important;
                pointer-events: none !important;
                z-index: -1 !important;
            `;
            
            hamburger.classList.remove('active');
            document.body.style.overflow = '';
            sidebarAberto = false;
        }
        
        // Gerenciar responsividade  
        function handleResize() {
            // Se mudou para desktop, fechar sidebar
            if (window.innerWidth > 1024 && sidebarAberto) {
                fecharSidebar();
            }
            
            // Reinicializar estado
            initializeSidebarState();
        }
        
        // Debounce para otimizar performance
        let resizeTimeout;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(handleResize, 150);
        });
        
        // Executar uma vez no carregamento
        handleResize();

    </script>
</body>
</html>